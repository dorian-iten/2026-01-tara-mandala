<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Mantra Visualization</title>

  <!-- PWA / iOS fullscreen support -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Noto+Sans:wght@400;600;700&display=swap"
    rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
      background: radial-gradient(circle at center,
          #f0e0ff 0%,
          #e0f0ff 12.5%,
          #e0ffe0 25%,
          #fff8e0 37.5%,
          #ffe0e8 50%,
          #f0e0ff 62.5%,
          #e0f0ff 75%,
          #e0ffe0 87.5%,
          #fff8e0 100%);
      overflow: hidden;
      touch-action: none;
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;

      /* Use mask to allow color control via background-color */
      background-color: rgba(255, 255, 255, 0.08);
      -webkit-mask-image: url('images/pattern.svg');
      mask-image: url('images/pattern.svg');
      -webkit-mask-size: 100px 100px;
      mask-size: 100px 100px;
      -webkit-mask-repeat: repeat;
      mask-repeat: repeat;

      /* Subtle highlight effect - soft glow */
      filter: brightness(1.1) drop-shadow(0 0 1px rgba(255, 255, 255, 0.4));
      -webkit-filter: brightness(1.1) drop-shadow(0 0 1px rgba(255, 255, 255, 0.4));

      pointer-events: none;
      z-index: 0;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
      z-index: 2;
    }

    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1;
      background:
        linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%),
        linear-gradient(to left, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%),
        linear-gradient(to top, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%),
        linear-gradient(to right, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%);
      background-size: 100% 10%, 10% 100%, 100% 10%, 10% 100%;
      background-position: top, right, bottom, left;
      background-repeat: no-repeat;
      transition: background 0.5s ease;
    }

    /* Custom dropdown - Light theme */
    #schema-selector {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }

    .custom-dropdown {
      position: relative;
      min-width: 280px;
    }

    .dropdown-trigger {
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.85);
      border: none;
      border-radius: 10px;
      color: #2d1b4e;
      font-family: "Noto Sans", sans-serif;
      font-size: 16px;
      font-weight: 400;
      cursor: pointer;
      backdrop-filter: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      transition: box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1), border-radius 0.2s ease 0.25s;
      user-select: none;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.18);
    }

    .dropdown-trigger:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .dropdown-trigger.active {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      transition: box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 6px solid rgba(45, 27, 78, 0.7);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .dropdown-trigger.active .dropdown-arrow {
      transform: rotate(180deg);
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.85);
      border: none;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .custom-dropdown:hover .dropdown-menu.show {
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    .dropdown-menu.show {
      max-height: 500px;
      opacity: 1;
      pointer-events: all;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .dropdown-option {
      padding: 16px 26px;
      color: rgba(45, 27, 78, 0.85);
      font-family: "Noto Sans", sans-serif;
      font-size: 16px;
      font-weight: 400;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
      position: relative;
      background: transparent;
    }

    .dropdown-option:first-child {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    }

    .dropdown-menu:not(.show) .dropdown-option:first-child {
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      transition: border-radius 0.2s ease 0.15s;
    }

    .dropdown-option:hover {
      color: rgba(45, 27, 78, 1);
      border-left-color: rgba(45, 27, 78, 0.5);
      background: rgba(240, 235, 255, 0.5);
    }

    .dropdown-option.selected {
      color: rgba(45, 27, 78, 1);
      border-left-color: rgba(45, 27, 78, 0.5);
      background: rgba(230, 220, 250, 0.4);
    }

    /* Speed controls - Light theme */
    #speed-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      border: 0.5px solid rgba(200, 200, 200, 0.3);
      backdrop-filter: blur(30px);
      transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
      opacity: 1;
      visibility: visible;
    }

    /* Desktop only: hide controls when inactive */
    @media (min-width: 769px) {
      #speed-controls.controls-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
    }

    #speed-controls:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(200, 200, 200, 0.5);
    }

    .speed-btn {
      padding: 8px 14px;
      border-radius: 50px;
      background: transparent;
      border: 1px solid transparent;
      color: rgba(45, 27, 78, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Noto Sans", sans-serif;
      font-size: 15px;
      font-weight: 400;
      user-select: none;
      line-height: 1;
      min-width: 36px;
    }

    .speed-btn:hover {
      color: rgba(45, 27, 78, 0.9);
      background: rgba(200, 190, 230, 0.3);
      transform: none;
    }

    .speed-btn:active {
      transform: scale(0.95);
      background: rgba(200, 190, 230, 0.5);
    }

    #speed-label {
      color: rgba(45, 27, 78, 0.8);
      font-size: 13px;
      min-width: 65px;
      text-align: center;
      font-family: "Noto Sans", sans-serif;
      font-weight: 400;
      padding: 0 4px;
    }

    #speed-value {
      color: rgba(45, 27, 78, 1);
      font-weight: 600;
    }

    /* Mode controls - Light theme */
    #mode-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      border: 0.5px solid rgba(200, 200, 200, 0.3);
    }

    .mode-btn {
      padding: 10px 24px;
      border-radius: 50px;
      background: transparent;
      border: 1px solid rgba(120, 100, 180, 0);
      color: rgba(45, 27, 78, 0.6);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Noto Sans", sans-serif;
      font-size: 16px;
      font-weight: 400;
      user-select: none;
      flex: 1;
      min-width: 0;
      text-align: center;
      box-shadow: none;
    }

    .mode-btn:hover {
      color: rgba(45, 27, 78, 0.8);
    }

    .mode-btn.active {
      background: rgba(200, 190, 230, 0.6);
      border: 1px solid rgba(120, 100, 180, 0.5);
      color: rgba(45, 27, 78, 0.9);
      box-shadow: none;
    }

    .mode-btn:active {
      transform: scale(0.98);
    }

    /* Fullscreen toggle - Light theme */
    #fullscreen-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: 0.5px solid rgba(102, 126, 234, 0.3);
      backdrop-filter: blur(30px);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 0.7;
    }

    #fullscreen-toggle:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.7);
      border-color: rgba(102, 126, 234, 0.5);
      transform: scale(1.05);
    }

    #fullscreen-toggle:active {
      transform: scale(0.95);
    }

    #fullscreen-toggle svg {
      width: 18px;
      height: 18px;
      stroke: rgba(45, 27, 78, 0.8);
      stroke-width: 2;
      fill: none;
    }

    /* Navigation controls - Light theme */
    #nav-controls {
      position: absolute;
      bottom: 30px;
      left: 20px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      border: 0.5px solid rgba(200, 200, 200, 0.3);
      backdrop-filter: blur(30px);
      transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
      opacity: 1;
      visibility: visible;
    }

    /* Desktop only: hide controls when inactive */
    @media (min-width: 769px) {
      #nav-controls.controls-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
    }

    #nav-controls:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(200, 200, 200, 0.5);
    }

    .nav-btn {
      padding: 8px 14px;
      border-radius: 50px;
      background: transparent;
      border: 1px solid transparent;
      color: rgba(45, 27, 78, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Noto Sans", sans-serif;
      font-size: 15px;
      font-weight: 400;
      user-select: none;
      line-height: 1;
      min-width: 36px;
    }

    .nav-btn:hover {
      background: rgba(200, 190, 230, 0.3);
      transform: none;
    }

    .nav-btn:active {
      transform: scale(0.95);
      background: rgba(200, 190, 230, 0.5);
    }

    .nav-btn svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: none;
    }

    /* Audio controls */
    #audio-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 20px;
      border-radius: 50px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      display: none;
      /* Disabled for now */
      align-items: center;
      gap: 12px;
    }

    #play-pause-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(100, 150, 255, 0.3);
      border: 2px solid rgba(100, 150, 255, 0.8);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      font-size: 20px;
    }

    #play-pause-btn:hover {
      background: rgba(100, 150, 255, 0.5);
      transform: scale(1.05);
    }

    #play-pause-btn:active {
      transform: scale(0.95);
    }

    #audio-info {
      color: white;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #audio-status {
      opacity: 0.7;
      font-size: 11px;
    }

    .hidden {
      display: none !important;
    }

    /* Canvas container for main visualization */
    #container canvas {
      width: 100%;
      height: 100%;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      .custom-dropdown {
        min-width: 240px;
      }

      .dropdown-trigger,
      .dropdown-option {
        font-size: 16px;
        padding: 14px 18px;
      }

      #fullscreen-toggle {
        top: 15px;
        right: 15px;
        width: 38px;
        height: 38px;
      }

      #fullscreen-toggle svg {
        width: 16px;
        height: 16px;
      }

      #audio-controls {
        bottom: 20px;
        padding: 10px 16px;
      }

      #play-pause-btn {
        width: 42px;
        height: 42px;
        font-size: 18px;
      }

      #audio-info {
        font-size: 12px;
      }
    }

    /* Portrait mobile - compact UI */
    @media (max-width: 768px) and (orientation: portrait) {
      #schema-selector {
        top: 10px;
        left: 10px;
      }

      .custom-dropdown {
        min-width: 220px;
      }

      .dropdown-trigger,
      .dropdown-option {
        font-size: 15px;
        padding: 12px 16px;
      }

      #fullscreen-toggle {
        top: 10px;
        right: 10px;
        width: 36px;
        height: 36px;
      }

      #fullscreen-toggle svg {
        width: 15px;
        height: 15px;
      }

      /* Navigation controls - bottom left */
      #nav-controls {
        bottom: 20px;
        left: 20px;
        right: auto;
        transform: none;
      }

      /* Speed controls - bottom right */
      #speed-controls {
        bottom: 20px;
        left: auto;
        right: 20px;
        transform: none;
      }

      #audio-controls {
        bottom: 15px;
        padding: 8px 12px;
        gap: 8px;
      }

      #play-pause-btn {
        width: 38px;
        height: 38px;
        font-size: 16px;
      }

      #audio-info {
        font-size: 11px;
        max-width: 150px;
      }

      .dropdown-menu.show {
        max-height: 400px;
      }
    }

    /* Landscape mobile - more compact */
    @media (max-height: 500px) and (orientation: landscape) {
      #schema-selector {
        top: 8px;
        left: 8px;
      }

      .custom-dropdown {
        min-width: 200px;
      }

      .dropdown-trigger,
      .dropdown-option {
        font-size: 14px;
        padding: 10px 14px;
      }

      #fullscreen-toggle {
        top: 8px;
        right: 8px;
        width: 32px;
        height: 32px;
      }

      #fullscreen-toggle svg {
        width: 14px;
        height: 14px;
      }

      #speed-controls {
        bottom: auto;
        left: auto;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        flex-direction: column;
        padding: 6px;
        gap: 4px;
      }

      .speed-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
        padding: 6px;
      }

      #speed-label {
        font-size: 12px;
        min-width: auto;
        writing-mode: horizontal-tb;
        text-orientation: initial;
        transform: none;
        font-size: 0;
      }

      #speed-value {
        font-size: 12px;
      }

      #audio-controls {
        bottom: 10px;
        padding: 6px 10px;
        gap: 6px;
      }

      #play-pause-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      #audio-info {
        font-size: 10px;
        max-width: 120px;
      }

      #audio-status {
        display: none;
      }

      /* Mode controls - Right side for landscape mobile */
      #mode-controls {
        bottom: auto;
        left: auto;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        flex-direction: column;
        padding: 0;
        gap: 4px;
        background: transparent;
        border: none;
        box-shadow: none;
        border-radius: 0;
      }

      .mode-btn {
        background: rgba(255, 255, 255, 0.4);
        border: 1px solid rgba(200, 200, 200, 0.2);
        border-radius: 50px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        min-width: 0;
        width: 100%;
      }

      .mode-btn.active {
        background: rgba(255, 255, 255, 0.85);
        border: 1px solid rgba(200, 200, 200, 0.3);
      }

      .mode-btn:active {
        transform: none;
      }

      /* Navigation controls - Middle left for landscape mobile */
      #nav-controls {
        bottom: auto;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        flex-direction: column;
        padding: 6px;
        gap: 4px;
      }

      .nav-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        font-size: 14px;
      }

      .dropdown-menu.show {
        max-height: calc(100vh - 120px);
      }

    }
  </style>
</head>

<body>
  <div id="vignette"></div>
  <div id="container">
    <canvas id="canvas3"></canvas>
  </div>

  <div id="schema-selector">
    <div class="custom-dropdown">
      <div class="dropdown-trigger">
        <span class="dropdown-label">Tara Vajra Sarasvati</span>
        <div class="dropdown-arrow"></div>
      </div>
      <div class="dropdown-menu">
        <!-- Options will be populated dynamically from mantras.json -->
      </div>
    </div>
  </div>

  <button id="fullscreen-toggle" aria-label="Toggle fullscreen">
    <svg viewBox="0 0 24 24">
      <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
        class="fullscreen-enter" />
      <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"
        class="fullscreen-exit" style="display:none;" />
    </svg>
  </button>

  <div id="mode-controls" style="display: none;">
    <button class="mode-btn active" id="mode-ring" aria-label="Ring mode">Ring</button>
    <button class="mode-btn" id="mode-billboard" aria-label="Billboard mode">Flat</button>
  </div>

  <div id="speed-controls">
    <button class="speed-btn" id="speed-decrease" aria-label="Decrease speed">−</button>
    <div id="speed-label">Speed: <span id="speed-value">1.0×</span></div>
    <button class="speed-btn" id="speed-increase" aria-label="Increase speed">+</button>
  </div>

  <div id="nav-controls">
    <button class="nav-btn" id="nav-prev" aria-label="Previous mantra">
      <svg viewBox="0 0 24 24">
        <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <button class="nav-btn" id="nav-next" aria-label="Next mantra">
      <svg viewBox="0 0 24 24">
        <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>

  <div id="audio-controls">
    <button id="play-pause-btn" aria-label="Play/Pause">▶</button>
    <div id="audio-info">
      <div id="audio-title">Tara Vajra Sarasvati</div>
      <div id="audio-status">Ready to play</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // Default mantra syllables (for variations 1 and 2)
    const defaultSyllables = ["OṂ", "TĀ", "RE", "TU", "TTĀ", "RE", "TU", "RE", "PRA", "JÑĀ", "HRĪṂ", "HRĪṂ", "SVĀ", "HĀ"];

    // Mantras data (loaded from JSON)
    let mantras = [];
    let currentMantraIndex = 0;

    // Style 3 references
    let style3Scene, style3Camera, style3Renderer, style3Controls, style3Composer;
    let style3Tam, style3SyllableGroup, style3MoonDisc;
    let style3MoonDiscOutline, style3MoonDiscOutlineMat;

    // Helper: Create text texture with proper aspect ratio
    // Returns { texture, aspectRatio } where aspectRatio = width/height
    function createTextTexture(text, fontSize = 64, color = '#ffffff') {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Set font and measure text
      const font = `bold ${fontSize}px "Crimson Pro", serif`;
      ctx.font = font;
      const metrics = ctx.measureText(text);

      // Get text dimensions with robust fallbacks
      const textWidth = Math.max(metrics.width, fontSize * 0.5);
      const textHeight = Math.max(
        (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0),
        fontSize * 0.85 // Fallback based on typical font metrics
      );

      // Add padding around text
      const padding = fontSize * 0.4;
      const canvasWidth = Math.max(64, Math.ceil(textWidth + padding * 2));
      const canvasHeight = Math.max(64, Math.ceil(textHeight + padding * 2));

      // Set canvas size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Redraw with correct canvas size (need to re-set font after resize)
      ctx.font = font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = color;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;

      const aspectRatio = canvas.width / canvas.height;

      return {
        texture,
        aspectRatio: isNaN(aspectRatio) || aspectRatio <= 0 ? 1 : aspectRatio
      };
    }

    // Helper: Create text texture with outline and proper aspect ratio
    // Returns { texture, aspectRatio } where aspectRatio = width/height
    function createTextTextureWithOutline(text, fontSize = 64, fillColor = '#ffffff', outlineColor = '#000000', outlineWidth = 3) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Set font and measure text
      const font = `bold ${fontSize}px "Crimson Pro", serif`;
      ctx.font = font;
      const metrics = ctx.measureText(text);

      // Get text dimensions with robust fallbacks
      const textWidth = Math.max(metrics.width, fontSize * 0.5);
      const textHeight = Math.max(
        (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0),
        fontSize * 0.85 // Fallback based on typical font metrics
      );

      // Add padding around text (account for outline)
      const padding = fontSize * 0.4 + outlineWidth * 2;
      const canvasWidth = Math.max(64, Math.ceil(textWidth + padding * 2));
      const canvasHeight = Math.max(64, Math.ceil(textHeight + padding * 2));

      // Set canvas size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Redraw with correct canvas size (need to re-set font after resize)
      ctx.font = font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw outline first
      if (outlineWidth > 0) {
        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = outlineWidth * 2;
        ctx.lineJoin = 'round';
        ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
      }

      // Draw fill
      ctx.fillStyle = fillColor;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;

      const aspectRatio = canvas.width / canvas.height;

      return {
        texture,
        aspectRatio: isNaN(aspectRatio) || aspectRatio <= 0 ? 1 : aspectRatio
      };
    }

    // Helper: Create TAM texture from SVG - returns {texture, aspectRatio}
    // High resolution for crisp rendering at all angles
    async function loadTamTexture(color = '#4a3a6a', renderer = null) {
      return new Promise((resolve) => {
        fetch('images/tam-paths.svg')
          .then(r => r.text())
          .then(svgText => {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = svgDoc.documentElement;
            const path = svgDoc.querySelector('path');
            if (path) path.setAttribute('fill', color);

            // Get original SVG dimensions for aspect ratio
            const viewBox = svgEl.getAttribute('viewBox');
            let svgWidth = 100, svgHeight = 100;
            if (viewBox) {
              const parts = viewBox.split(/\s+/);
              svgWidth = parseFloat(parts[2]) || 100;
              svgHeight = parseFloat(parts[3]) || 100;
            } else {
              svgWidth = parseFloat(svgEl.getAttribute('width')) || 100;
              svgHeight = parseFloat(svgEl.getAttribute('height')) || 100;
            }
            const aspectRatio = svgWidth / svgHeight;

            const serializer = new XMLSerializer();
            const modifiedSvg = serializer.serializeToString(svgDoc.documentElement);
            const blob = new Blob([modifiedSvg], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = () => {
              // HIGH RESOLUTION canvas for crisp rendering when foreshortened
              const canvasHeight = 2048;
              const canvasWidth = Math.round(canvasHeight * aspectRatio);

              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = canvasWidth;
              canvas.height = canvasHeight;

              // Enable high quality rendering
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

              const texture = new THREE.CanvasTexture(canvas);
              // High quality texture filtering for foreshortened views
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.generateMipmaps = true;
              // Anisotropic filtering for sharp rendering at angles
              if (renderer && renderer.capabilities) {
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
              } else {
                texture.anisotropy = 16; // Default high anisotropy
              }
              texture.needsUpdate = true;
              URL.revokeObjectURL(url);
              resolve({ texture, aspectRatio });
            };
            img.src = url;
          })
          .catch(() => {
            // Fallback: create text-based TAM
            resolve({ texture: createTextTexture('TAM', 80, color), aspectRatio: 1 });
          });
      });
    }

    // Helper: Load 3D TAM mesh from GLB file
    // Returns a promise that resolves to a cloned THREE.Group with the TAM mesh
    const gltfLoader = new GLTFLoader();
    let cachedTamGltf = null;

    async function loadTam3D(color = '#4a3a6a', scale = 1.0) {
      return new Promise((resolve, reject) => {
        const createTamMesh = (gltf) => {
          const tam = gltf.scene.clone(true);

          // Remove reflection meshes - they have negative Y scale (mirrored)
          const toRemove = [];
          tam.traverse((child) => {
            if (child.isMesh) {
              // Get the world scale to check for mirrored geometry
              const worldScale = new THREE.Vector3();
              child.getWorldScale(worldScale);

              // Negative Y scale indicates a mirrored/reflected mesh
              if (worldScale.y < 0) {
                toRemove.push(child);
              }
            }
          });

          // Remove the mirrored meshes
          toRemove.forEach(mesh => mesh.removeFromParent());

          // Apply color to remaining meshes
          tam.traverse((child) => {
            if (child.isMesh) {
              child.material = new THREE.MeshBasicMaterial({
                color: new THREE.Color(color),
                side: THREE.DoubleSide
              });
            }
          });

          // Scale the model
          tam.scale.set(scale, scale, scale);

          resolve(tam);
        };

        if (cachedTamGltf) {
          createTamMesh(cachedTamGltf);
        } else {
          gltfLoader.load(
            '3D/tam.glb',
            (gltf) => {
              cachedTamGltf = gltf;
              createTamMesh(gltf);
            },
            undefined,
            (error) => {
              console.error('Failed to load TAM 3D model:', error);
              reject(error);
            }
          );
        }
      });
    }

    // Schema definitions - loaded from JSON config
    let schemas = [];

    // Load mantras configuration from local JSON file
    async function loadMantrasConfig() {
      try {
        const response = await fetch(`mantras.json?t=${Date.now()}`, {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
          }
        });

        const config = await response.json();

        // Process schemas: convert outlineColor string to number, ensure defaults
        schemas = config.mantras.map(mantra => {
          let outlineColor = null;
          if (mantra.outlineColor) {
            // Handle both "0x1a3a5c" and "#1a3a5c" formats
            const colorStr = String(mantra.outlineColor).replace(/^#/, '').replace(/^0x/i, '');
            outlineColor = parseInt(colorStr, 16);
          }

          // Process syllableStyle if present
          let syllableStyle = null;
          if (mantra.syllableStyle) {
            const style = mantra.syllableStyle;
            syllableStyle = {
              fill: style.fill || '#ffffff',  // Keep as hex string for Canvas API
              outlineColor: style.outlineColor || '#000000',  // Keep as hex string for Canvas API
              outlineWidth: style.outlineWidth || 0
            };
          }

          return {
            name: mantra.name,
            id: mantra.id,
            syllables: mantra.syllables,
            audioFile: mantra.audioFile || null,
            tamColor: mantra.tamColor || '#ffffff',
            tamOutlineColor: mantra.tamOutlineColor || null,
            outlineColor: outlineColor,
            syllableStyle: syllableStyle,
            backgroundGradient: mantra.backgroundGradient || null,
            startIndex: mantra.startIndex || 0,
            releaseDate: mantra.releaseDate || "",
            releaseDateOverride: mantra.releaseDateOverride || false
          };
        });

        console.log('Loaded mantras configuration:', schemas);
        mantras = schemas; // Keep mantras for compatibility
        return schemas;
      } catch (error) {
        console.error('Failed to load mantras.json, using fallback:', error);
        // Fallback to default configuration
        schemas = [
          {
            name: "Tara Vajra Sarasvati",
            id: "1",
            syllables: ["OṂ", "TĀ", "RE", "TU", "TTĀ", "RE", "TU", "RE", "PRA", "JÑĀ", "HRĪṂ", "HRĪṂ", "SVĀ", "HĀ"],
            outlineColor: 0x1a3a5c,
            syllableStyle: null,
            backgroundGradient: null,
            startIndex: 0
          }
        ];
        mantras = schemas;
        return schemas;
      }
    }

    // Load mantras from JSON (alias for compatibility)
    async function loadMantras() {
      return await loadMantrasConfig();
    }

    // Helper function to darken a hex color
    function darkenColor(hex, amount) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      // Darken by reducing each component
      const newR = Math.max(0, Math.floor(r * (1 - amount)));
      const newG = Math.max(0, Math.floor(g * (1 - amount)));
      const newB = Math.max(0, Math.floor(b * (1 - amount)));

      // Convert back to hex
      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }

    // Helper function to calculate luminance from hex color
    function getColorLuminance(hexColor) {
      // Remove # if present
      const hex = hexColor.replace('#', '');
      
      // Parse RGB
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      
      // Calculate relative luminance (ITU-R BT.709)
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    // Helper function to get nav button color based on tamColor
    function getNavButtonColor(tamColor) {
      if (!tamColor) {
        return '#2d1b4e'; // Default dark color
      }
      
      const luminance = getColorLuminance(tamColor);
      
      // If luminance is high (light color), use dark gray
      // Threshold of 0.8 means very light colors (near white) will be inverted
      if (luminance > 0.8) {
        return '#3a3a3a'; // Dark gray
      }
      
      return tamColor;
    }

    // Helper function to extract a representative color from gradient
    function extractColorFromGradient(gradientConfig) {
      if (!gradientConfig || !gradientConfig.colors || gradientConfig.colors.length === 0) {
        // Default background colors - use a representative color from the default gradient
        return '#e0f0ff'; // A light blue from the default gradient
      }

      // For radial gradients, prefer center colors; for linear, use middle colors
      const colors = gradientConfig.colors;

      // Find the color closest to center (position 0% or closest to center)
      let centerColor = colors[0].color;
      let minDistance = Math.abs(colors[0].position - 0);

      for (const colorStop of colors) {
        const distance = Math.abs(colorStop.position - 0);
        if (distance < minDistance) {
          minDistance = distance;
          centerColor = colorStop.color;
        }
      }

      return centerColor;
    }

    // Update vignette based on current background
    function updateVignette(gradientConfig) {
      const vignetteEl = document.getElementById('vignette');
      if (!vignetteEl) return;

      // Extract a representative color from the gradient
      const baseColor = extractColorFromGradient(gradientConfig);

      // Darken the color for the vignette (darken by 70-80% for stronger effect)
      const darkenedColor = darkenColor(baseColor, 0.75);

      // Convert hex to rgba for better control
      const r = parseInt(darkenedColor.substring(1, 3), 16);
      const g = parseInt(darkenedColor.substring(3, 5), 16);
      const b = parseInt(darkenedColor.substring(5, 7), 16);

      // Create vignette that darkens all edges uniformly (not just corners)
      // Use multiple linear gradients - one for each edge
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const maxOpacity = luminance > 0.5 ? 0.85 : 0.75; // Strong opacity at edges
      const midOpacity = maxOpacity * 0.5; // Mid-range opacity for smooth transition

      // Calculate 10% of viewport for edge darkening
      // Use linear gradients for each edge that fade from transparent to dark
      const edgeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.4})`; // Reduced opacity
      const midEdgeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.2})`;
      const fadeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.08})`;
      const veryFadeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.03})`;

      // Top edge: softer, more gradual fade (10% coverage)
      const topGradient = `linear-gradient(to bottom, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;
      // Right edge: fade from right
      const rightGradient = `linear-gradient(to left, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;
      // Bottom edge: fade from bottom
      const bottomGradient = `linear-gradient(to top, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;
      // Left edge: fade from left
      const leftGradient = `linear-gradient(to right, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;

      // Combine all gradients
      vignetteEl.style.background = `${topGradient}, ${rightGradient}, ${bottomGradient}, ${leftGradient}`;
      vignetteEl.style.backgroundSize = '100% 10%, 10% 100%, 100% 10%, 10% 100%';
      vignetteEl.style.backgroundPosition = 'top, right, bottom, left';
      vignetteEl.style.backgroundRepeat = 'no-repeat';
    }

    // Apply background gradient from config
    function applyBackgroundGradient(gradientConfig) {
      if (!gradientConfig || !gradientConfig.colors) {
        // Use default background
        document.body.style.background = 'radial-gradient(circle at center, #f0e0ff 0%, #e0f0ff 12.5%, #e0ffe0 25%, #fff8e0 37.5%, #ffe0e8 50%, #f0e0ff 62.5%, #e0f0ff 75%, #e0ffe0 87.5%, #fff8e0 100%)';
        updateVignette(null); // Update vignette for default background
        return;
      }

      const colors = gradientConfig.colors.map(c => `${c.color} ${c.position}%`).join(', ');
      const gradientType = gradientConfig.type === 'linear' ? 'linear-gradient' : 'radial-gradient';
      const gradientValue = gradientType === 'radial-gradient'
        ? `radial-gradient(circle at center, ${colors})`
        : `linear-gradient(${gradientConfig.direction || 'to bottom'}, ${colors})`;

      document.body.style.background = gradientValue;
      updateVignette(gradientConfig); // Update vignette when background changes
    }

    // Check for URL parameter to show all mantras
    const urlParams = new URLSearchParams(window.location.search);
    const showAllMantras = urlParams.has('showall');

    // Helper function to check if a mantra should be displayed
    function isMantraReleased(schema) {
      // If showall parameter is present, show all mantras
      if (showAllMantras) {
        return true;
      }

      // If override is true, always show the mantra
      if (schema.releaseDateOverride === true) {
        return true;
      }

      // If no release date is set, hide the mantra
      if (!schema.releaseDate || schema.releaseDate === '') {
        return false;
      }

      // Check if release date has passed
      const targetDate = new Date(schema.releaseDate);
      const now = new Date();
      targetDate.setHours(0, 0, 0, 0);
      now.setHours(0, 0, 0, 0);

      return now >= targetDate;
    }

    // Populate dropdown with mantras from config
    function populateDropdown() {
      const dropdownMenu = document.querySelector('.dropdown-menu');
      const dropdownLabel = document.querySelector('.dropdown-label');

      // Clear existing options
      dropdownMenu.innerHTML = '';

      // Create options for each mantra that is released
      schemas.forEach((schema, index) => {
        // Only add option if mantra is released
        if (isMantraReleased(schema)) {
          const option = document.createElement('div');
          option.className = `dropdown-option ${index === currentMantraIndex ? 'selected' : ''}`;
          option.textContent = schema.name;
          option.dataset.value = index;
          dropdownMenu.appendChild(option);
        }
      });

      // Set initial label
      if (schemas[currentMantraIndex]) {
        dropdownLabel.textContent = schemas[currentMantraIndex].name;
      }
    }

    // Update navigation button colors based on current mantra
    function updateNavButtonColors() {
      const navButtons = document.querySelectorAll('.nav-btn');
      if (navButtons.length === 0) return;
      
      const tamColor = schemas[currentMantraIndex]?.tamColor;
      const buttonColor = getNavButtonColor(tamColor);
      
      navButtons.forEach(btn => {
        btn.style.color = buttonColor;
      });
    }

    // Update moon disc outline color based on current mantra
    function updateMoonDiscOutlineColor() {
      if (!style3MoonDiscOutlineMat) return;
      
      const schema = schemas[currentMantraIndex];
      // Use syllable outline color if available, otherwise tam color, otherwise default
      const syllableStyle = schema.syllableStyle || {};
      const outlineColor = syllableStyle.outlineColor || schema.tamColor || '#4a3a6a';
      style3MoonDiscOutlineMat.color.set(outlineColor);
    }

    // ============================================
    // STYLE 1: Top-Down View
    // ============================================
    async function initStyle1() {
      const container = document.getElementById('canvas1');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      camera.position.set(0, 8, 0.1);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ canvas: container, antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Orb of white light - HIGH POLYGON COUNT for smooth appearance
      const orbGeom = new THREE.SphereGeometry(2.5, 128, 128);
      const orbMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      scene.add(new THREE.Mesh(orbGeom, orbMat));

      // Moon disc - SMALLER, syllables orbit OUTSIDE it - WHITE with outline
      const discGeom = new THREE.CircleGeometry(1.4, 128);
      const discMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide
      });
      const moonDisc = new THREE.Mesh(discGeom, discMat);
      moonDisc.rotation.x = -Math.PI / 2;
      moonDisc.position.y = -0.5;
      scene.add(moonDisc);

      // Subtle outline ring for moon disc
      const outlineGeom = new THREE.RingGeometry(1.38, 1.42, 128);
      const outlineMat = new THREE.MeshBasicMaterial({
        color: 0x3a2a5a, // Same as TAM color
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      const outline = new THREE.Mesh(outlineGeom, outlineMat);
      outline.rotation.x = -Math.PI / 2;
      outline.position.y = -0.49;
      scene.add(outline);

      // TAM in center - 2D SVG texture on upright plane
      const { texture: tamTexture, aspectRatio: tamAspect } = await loadTamTexture('#3a2a5a', renderer);
      const tamHeight = 1.8;
      const tamWidth = tamHeight * tamAspect;
      const tamGeom = new THREE.PlaneGeometry(tamWidth, tamHeight);
      const tamMat = new THREE.MeshBasicMaterial({
        map: tamTexture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const tam = new THREE.Mesh(tamGeom, tamMat);
      tam.position.set(0, tamHeight / 2 - 0.49, 0);
      scene.add(tam);

      // 3D TAM alternative (commented out for future use):
      // const tam = await loadTam3D('#3a2a5a', 2.5);
      // tam.position.set(0, -0.49, 0);
      // scene.add(tam);

      // Syllable ring (as dots/crowns when viewed from above) - OUTSIDE the moon disc
      const syllableGroup = new THREE.Group();
      const radius = 1.8; // Larger than moon disc radius (1.4)

      // Pre-create textures to get aspect ratios for proper sizing
      const syllableData = defaultSyllables.map(syl => {
        const { texture, aspectRatio } = createTextTexture(syl, 48, '#3a2a5a');
        return { text: syl, texture, aspectRatio };
      });

      // Calculate dot/label sizes based on available space
      const numSyllables = defaultSyllables.length;
      const anglePerSyllable = (Math.PI * 2) / numSyllables;
      const arcLength = anglePerSyllable * radius;
      const maxLabelHeight = arcLength * 0.7; // Leave some gap between syllables

      defaultSyllables.forEach((syl, i) => {
        const angle = (i / numSyllables) * Math.PI * 2 - Math.PI / 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const data = syllableData[i];
        const labelHeight = Math.min(maxLabelHeight, 0.25);
        const labelWidth = labelHeight * data.aspectRatio;

        // White circles representing syllable crowns - size based on label
        const dotRadius = Math.max(labelWidth, labelHeight) * 0.6;
        const dotGeom = new THREE.CircleGeometry(dotRadius, 32);
        const dotMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.95
        });
        const dot = new THREE.Mesh(dotGeom, dotMat);
        dot.rotation.x = -Math.PI / 2;
        dot.position.set(x, -0.48, z);
        syllableGroup.add(dot);

        // Label with proper aspect ratio
        const labelGeom = new THREE.PlaneGeometry(labelWidth, labelHeight);
        const labelMat = new THREE.MeshBasicMaterial({
          map: data.texture,
          transparent: true,
          depthWrite: false
        });
        const label = new THREE.Mesh(labelGeom, labelMat);
        label.rotation.x = -Math.PI / 2;
        label.position.set(x, -0.47, z);
        syllableGroup.add(label);
      });

      scene.add(syllableGroup);

      // Animation - counter-clockwise when viewed from above (positive Y rotation)
      let time = 0;
      function animate() {
        requestAnimationFrame(animate);
        time += 0.002;
        syllableGroup.rotation.y = time; // Counter-clockwise from above
        renderer.render(scene, camera);
      }
      animate();
    }

    // ============================================
    // STYLE 2: Orbital Ring (Ring mode like index.html)
    // ============================================
    async function initStyle2() {
      const container = document.getElementById('canvas2');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      camera.position.set(0, 2.5, 6);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ canvas: container, antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false;
      controls.autoRotate = false;

      // Core white orb
      const orbGeom = new THREE.SphereGeometry(2, 128, 128);
      const orbMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        depthWrite: false
      });
      const orb = new THREE.Mesh(orbGeom, orbMat);
      orb.renderOrder = -1;
      scene.add(orb);

      // Two outer rings
      const ring1Geom = new THREE.SphereGeometry(2.15, 128, 128);
      const ring1Mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
      });
      scene.add(new THREE.Mesh(ring1Geom, ring1Mat));

      const ring2Geom = new THREE.SphereGeometry(2.3, 128, 128);
      const ring2Mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      scene.add(new THREE.Mesh(ring2Geom, ring2Mat));

      // Larger moon disc at base of TAM - WHITE with outline
      const discGeom = new THREE.CircleGeometry(1.3, 128);
      const discMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide
      });
      const moonDisc = new THREE.Mesh(discGeom, discMat);
      moonDisc.rotation.x = -Math.PI / 2;
      moonDisc.position.y = -0.5;
      scene.add(moonDisc);

      // Subtle outline ring for moon disc
      const outlineGeom = new THREE.RingGeometry(1.28, 1.32, 128);
      const outlineMat = new THREE.MeshBasicMaterial({
        color: 0x4a3a6a, // Same as TAM color
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide
      });
      const outline = new THREE.Mesh(outlineGeom, outlineMat);
      outline.rotation.x = -Math.PI / 2;
      outline.position.y = -0.49;
      scene.add(outline);

      // TAM standing on moon disc - 2D SVG texture on upright plane, FIXED facing forward
      const { texture: tamTexture, aspectRatio: tamAspect } = await loadTamTexture('#4a3a6a', renderer);
      const tamHeight = 1.8;
      const tamWidth = tamHeight * tamAspect;
      const tamGeom = new THREE.PlaneGeometry(tamWidth, tamHeight);
      const tamMat = new THREE.MeshBasicMaterial({
        map: tamTexture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const tam = new THREE.Mesh(tamGeom, tamMat);
      tam.position.set(0, tamHeight / 2 - 0.5, 0); // On the moon disc
      scene.add(tam);

      // 3D TAM alternative (commented out for future use):
      // const tam = await loadTam3D('#4a3a6a', 2.0);
      // tam.position.set(0, -0.5, 0);
      // scene.add(tam);

      // Syllables orbiting around the moon disc edge - RING MODE (face outward)
      // All syllables at uniform height, width varies by natural aspect ratio
      const syllableGroup = new THREE.Group();
      const radius = 1.5;
      const syllableY = -0.35; // Closer to moon disc level

      // Pre-create all textures to get their aspect ratios
      const syllableData = defaultSyllables.map(syl => {
        const { texture, aspectRatio } = createTextTexture(syl, 72, '#5a4a7a');
        return { text: syl, texture, aspectRatio };
      });

      // Calculate uniform height and resulting widths
      const baseHeight = 0.5; // Uniform height for all syllables
      const syllableWidths = syllableData.map(d => baseHeight * d.aspectRatio);
      const totalArcWidth = syllableWidths.reduce((a, b) => a + b, 0);
      const circumference = 2 * Math.PI * radius;
      const numSyllables = defaultSyllables.length;

      // Calculate scale to fit all syllables with gaps (syllables take ~75% of circumference for larger text)
      const targetTextRatio = 0.75;
      const availableArc = circumference * targetTextRatio;
      const uniformScale = availableArc / totalArcWidth;
      const scaledHeight = baseHeight * uniformScale;
      const scaledWidths = syllableWidths.map(w => w * uniformScale);
      const totalScaledArc = scaledWidths.reduce((a, b) => a + b, 0);
      const gapSize = (circumference - totalScaledArc) / numSyllables;

      // Position syllables with even gaps
      let currentAngle = -Math.PI / 2; // Start at 12 o'clock

      syllableData.forEach((data, i) => {
        const syllableWidth = scaledWidths[i];

        // Add half gap + half syllable width to get center position
        currentAngle += (gapSize / 2 + syllableWidth / 2) / radius;

        const x = Math.cos(currentAngle) * radius;
        const z = Math.sin(currentAngle) * radius;

        // Use natural aspect ratio for geometry
        const geom = new THREE.PlaneGeometry(syllableWidth, scaledHeight);
        const mat = new THREE.MeshBasicMaterial({
          map: data.texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: true,
          depthWrite: false,
          alphaTest: 0.01
        });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(x, syllableY, z);

        // Face outward from center (ring mode)
        mesh.lookAt(x * 2, syllableY, z * 2);

        syllableGroup.add(mesh);

        // Move to end of this syllable + half gap for next
        currentAngle += (syllableWidth / 2 + gapSize / 2) / radius;
      });

      scene.add(syllableGroup);

      // Animation
      let time = 0;
      function animate() {
        requestAnimationFrame(animate);
        time += 0.002;
        syllableGroup.rotation.y = time;
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    // ============================================
    // STYLE 3: JSON-Driven Mantra Colors
    // ============================================
    let style3Time = 0; // Animation time for syllable rotation

    // Global references for Style 3 glow elements
    let style3Orb, style3Ring1, style3Ring2, style3GlowSprite;
    let isGlowEnabled = true;

    // Helper to update glow settings based on mantra ID
    function updateStyle3GlowSettings(mantraId) {
      if (!isGlowEnabled) {
        // Disable all glow elements
        if (style3Orb && style3Orb.material) {
          style3Orb.material.transparent = true;
          style3Orb.material.opacity = 0.0;
        }
        if (style3Ring1) style3Ring1.material.opacity = 0.0;
        if (style3Ring2) style3Ring2.material.opacity = 0.0;
        if (style3GlowSprite) style3GlowSprite.material.opacity = 0.0;
        return;
      }

      // List of "light" mantras that need toned down glow
      // IDs: 2, 15, 18, 19, 21
      const lightMantras = ['2', '15', '18', '19', '21'];

      const isLightMantra = lightMantras.includes(mantraId);

      console.log(`Mantra ID: ${mantraId}, Is Light: ${isLightMantra}`);

      if (isLightMantra) {
        // Toned down settings for light mantras - only opacity changes, not size

        // 1. Reduce orb opacity for lighter appearance (using MeshBasicMaterial like index.html)
        if (style3Orb && style3Orb.material) {
          style3Orb.material.transparent = true;
          style3Orb.material.opacity = 0.4; // Reduced opacity for light mantras
        }

        // 2. Reduce outer ring opacity (but keep same size)
        if (style3Ring1) style3Ring1.material.opacity = 0.1; // Was 0.15
        if (style3Ring2) style3Ring2.material.opacity = 0.05; // Was 0.08

        // 3. Reduce glow sprite opacity
        if (style3GlowSprite) style3GlowSprite.material.opacity = 0.2; // Was 0.5

      } else {
        // Default settings for other mantras (like the golden ones)

        // 1. Full opacity orb (using MeshBasicMaterial like index.html)
        if (style3Orb && style3Orb.material) {
          style3Orb.material.transparent = false;
          style3Orb.material.opacity = 1.0; // Full brightness
        }

        // 2. Standard outer ring opacity
        if (style3Ring1) style3Ring1.material.opacity = 0.3;
        if (style3Ring2) style3Ring2.material.opacity = 0.15;

        // 3. Standard glow sprite opacity
        if (style3GlowSprite) style3GlowSprite.material.opacity = 1.0;
      }
    }

    async function initStyle3() {
      const container = document.getElementById('canvas3');
      const width = window.innerWidth;
      const height = window.innerHeight;

      style3Scene = new THREE.Scene();
      style3Camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      const camPos = getCameraPosition();
      style3Camera.position.set(camPos.x, camPos.y, camPos.z);
      style3Camera.lookAt(0, 0, 0);

      style3Renderer = new THREE.WebGLRenderer({ canvas: container, antialias: true, alpha: true });
      style3Renderer.setSize(width, height);
      style3Renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      style3Controls = new OrbitControls(style3Camera, style3Renderer.domElement);
      style3Controls.enableDamping = true;
      style3Controls.dampingFactor = 0.05;
      style3Controls.enableZoom = false;
      style3Controls.autoRotate = false; // Camera stays still, syllables rotate

      // Fixed geometry sizes - must be consistent across all mantras
      const ORB_RADIUS = 2.0;
      const RING1_RADIUS = 2.15;
      const RING2_RADIUS = 2.3;
      const GLOW_SPRITE_SCALE = 5.5; // Fixed scale for glow sprite

      // Create radial gradient texture for edge glow
      function createEdgeGlowTexture3() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(
          size / 2, size / 2, size * 0.40,
          size / 2, size / 2, size * 0.50
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
      }

      // Core white orb - using MeshBasicMaterial like index.html for consistent size
      const orbGeom = new THREE.SphereGeometry(ORB_RADIUS, 128, 128);
      const orbMat = new THREE.MeshBasicMaterial({
        color: 0xffffff, // White
        transparent: false, // Fully opaque by default
        opacity: 1.0, // 100% opacity by default
        depthWrite: false, // Important: don't write depth so internal items show
        depthTest: true, // Enable depth test
        fog: false // Not affected by atmospheric fog
      });

      style3Orb = new THREE.Mesh(orbGeom, orbMat);
      style3Orb.renderOrder = -1; // Render behind everything
      style3Orb.scale.set(1, 1, 1); // Ensure consistent scale
      style3Scene.add(style3Orb);

      // Two outer rings
      const ring1Geom = new THREE.SphereGeometry(RING1_RADIUS, 128, 128);
      const ring1Mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
      });
      style3Ring1 = new THREE.Mesh(ring1Geom, ring1Mat);
      style3Ring1.scale.set(1, 1, 1); // Ensure consistent scale
      style3Scene.add(style3Ring1);

      const ring2Geom = new THREE.SphereGeometry(RING2_RADIUS, 128, 128);
      const ring2Mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      style3Ring2 = new THREE.Mesh(ring2Geom, ring2Mat);
      style3Ring2.scale.set(1, 1, 1); // Ensure consistent scale
      style3Scene.add(style3Ring2);

      // Edge glow sprite
      const glowTexture3 = createEdgeGlowTexture3();
      const glowMaterial3 = new THREE.SpriteMaterial({
        map: glowTexture3,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      style3GlowSprite = new THREE.Sprite(glowMaterial3);
      style3GlowSprite.scale.set(GLOW_SPRITE_SCALE, GLOW_SPRITE_SCALE, 1);
      style3GlowSprite.renderOrder = -2;
      style3Scene.add(style3GlowSprite);

      // Moon disc - WHITE with outline - LARGER within orb
      const discGeom = new THREE.CircleGeometry(1.5, 128);
      const discMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide
      });
      style3MoonDisc = new THREE.Mesh(discGeom, discMat);
      style3MoonDisc.rotation.x = -Math.PI / 2;
      style3MoonDisc.position.y = -0.5;
      style3Scene.add(style3MoonDisc);

      // Outline ring for moon disc (will be colored by mantra)
      const outlineGeom = new THREE.RingGeometry(1.48, 1.52, 128);
      style3MoonDiscOutlineMat = new THREE.MeshBasicMaterial({
        color: 0xcc0000, // Will be set by mantra
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide
      });
      style3MoonDiscOutline = new THREE.Mesh(outlineGeom, style3MoonDiscOutlineMat);
      style3MoonDiscOutline.rotation.x = -Math.PI / 2;
      style3MoonDiscOutline.position.y = -0.49;
      style3Scene.add(style3MoonDiscOutline);

      // TAM placeholder (will be replaced) - faces forward, never rotates
      style3Tam = new THREE.Group();
      style3Scene.add(style3Tam);

      // Syllables group - this will rotate
      style3SyllableGroup = new THREE.Group();
      style3Scene.add(style3SyllableGroup);

      // Load initial mantra
      await updateStyle3Mantra();

      // Animation - SYLLABLES spin counter-clockwise, TAM stays fixed
      function animate() {
        requestAnimationFrame(animate);
        style3Time += rotationSpeed * 0.001; // Use rotation speed from controls

        // Syllables rotate counter-clockwise around the TAM
        style3SyllableGroup.rotation.y = style3Time;

        // TAM stays fixed facing forward

        style3Controls.update();
        style3Renderer.render(style3Scene, style3Camera);
      }
      animate();
    }

    // Update Style 3 with current mantra
    async function updateStyle3Mantra() {
      if (mantras.length === 0) return;

      const mantra = mantras[currentMantraIndex];

      // Apply background gradient to body
      applyBackgroundGradient(mantra.backgroundGradient);

      // Apply dynamic glow settings based on mantra ID
      updateStyle3GlowSettings(mantra.id);

      // Ensure orb, rings, and glow sprite maintain consistent scale (safeguard)
      if (style3Orb) style3Orb.scale.set(1, 1, 1);
      if (style3Ring1) style3Ring1.scale.set(1, 1, 1);
      if (style3Ring2) style3Ring2.scale.set(1, 1, 1);
      if (style3GlowSprite) style3GlowSprite.scale.set(5.5, 5.5, 1);

      // Get colors
      const tamColor = mantra.tamColor || '#4a3a6a';
      const syllableStyle = mantra.syllableStyle || { fill: '#ffffff', outlineColor: '#000000', outlineWidth: 0 };

      // Update moon disc outline color to match syllable outline (has contrast on white mantras)
      // Use syllable outline color if available, otherwise tam color, otherwise default
      if (style3MoonDiscOutlineMat) {
        const outlineColor = syllableStyle.outlineColor || mantra.tamColor || '#4a3a6a';
        style3MoonDiscOutlineMat.color.set(outlineColor);
      }

      // Clear old TAM
      while (style3Tam.children.length > 0) {
        const child = style3Tam.children[0];
        child.traverse((obj) => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        });
        style3Tam.remove(child);
      }

      // Load new TAM - 2D SVG texture on upright plane with mantra color
      const { texture: tamTexture, aspectRatio: tamAspect } = await loadTamTexture(tamColor, style3Renderer);
      const tamHeight = 2.0;
      const tamWidth = tamHeight * tamAspect;
      const tamGeom = new THREE.PlaneGeometry(tamWidth, tamHeight);
      const tamMat = new THREE.MeshBasicMaterial({
        map: tamTexture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const tamMesh = new THREE.Mesh(tamGeom, tamMat);
      tamMesh.position.set(0, tamHeight / 2 - 0.5, 0); // On the moon disc
      style3Tam.add(tamMesh);

      // 3D TAM alternative (commented out for future use):
      // const tamMesh = await loadTam3D(tamColor, 2.5);
      // tamMesh.position.set(0, -0.5, 0);
      // style3Tam.add(tamMesh);

      // Clear old syllables
      while (style3SyllableGroup.children.length > 0) {
        const child = style3SyllableGroup.children[0];
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        }
        style3SyllableGroup.remove(child);
      }

      // Create new syllables with mantra styling
      // All syllables at uniform height, width varies by natural aspect ratio
      const syllables = mantra.syllables;
      const radius = 1.7;
      const syllableY = -0.35; // Closer to moon disc level
      const outlineWidth = (syllableStyle.outlineWidth || 0) * 200; // Scale for canvas

      // Pre-create all textures to get their aspect ratios
      const syllableData = syllables.map(syl => {
        const { texture, aspectRatio } = createTextTextureWithOutline(
          syl,
          72,
          syllableStyle.fill || '#ffffff',
          syllableStyle.outlineColor || '#000000',
          outlineWidth
        );
        return { text: syl, texture, aspectRatio };
      });

      // Calculate uniform height and resulting widths
      const baseHeight = 0.5; // Uniform height for all syllables
      const syllableWidths = syllableData.map(d => baseHeight * d.aspectRatio);
      const totalArcWidth = syllableWidths.reduce((a, b) => a + b, 0);
      const circumference = 2 * Math.PI * radius;
      const numSyllables = syllables.length;

      // Calculate scale to fit all syllables with gaps (syllables take ~75% of circumference for larger text)
      const targetTextRatio = 0.75;
      const availableArc = circumference * targetTextRatio;
      const uniformScale = availableArc / totalArcWidth;
      const scaledHeight = baseHeight * uniformScale;
      const scaledWidths = syllableWidths.map(w => w * uniformScale);
      const totalScaledArc = scaledWidths.reduce((a, b) => a + b, 0);
      const gapSize = (circumference - totalScaledArc) / numSyllables;

      // Position syllables with even gaps
      let currentAngle = -Math.PI / 2; // Start at 12 o'clock

      syllableData.forEach((data, i) => {
        const syllableWidth = scaledWidths[i];

        // Add half gap + half syllable width to get center position
        currentAngle += (gapSize / 2 + syllableWidth / 2) / radius;

        const x = Math.cos(currentAngle) * radius;
        const z = Math.sin(currentAngle) * radius;

        // Use natural aspect ratio for geometry
        const geom = new THREE.PlaneGeometry(syllableWidth, scaledHeight);
        const mat = new THREE.MeshBasicMaterial({
          map: data.texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: true,
          depthWrite: false,
          alphaTest: 0.01
        });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(x, syllableY, z);

        // Face outward from center (ring mode)
        mesh.lookAt(x * 2, syllableY, z * 2);

        style3SyllableGroup.add(mesh);

        // Move to end of this syllable + half gap for next
        currentAngle += (syllableWidth / 2 + gapSize / 2) / radius;
      });
    }

    // Navigation function
    function navigateToMantra(direction) {
      // Get all released mantras
      const releasedMantras = schemas
        .map((schema, index) => ({ schema, index }))
        .filter(({ schema }) => isMantraReleased(schema));

      if (releasedMantras.length === 0) return;

      // Find current position in released mantras
      const currentPos = releasedMantras.findIndex(({ index }) => index === currentSchema);
      
      if (currentPos === -1) return;

      // Calculate next position with wrapping
      let nextPos;
      if (direction === 'next') {
        nextPos = (currentPos + 1) % releasedMantras.length;
      } else {
        nextPos = (currentPos - 1 + releasedMantras.length) % releasedMantras.length;
      }

      const nextMantra = releasedMantras[nextPos];
      
      // Update schema
      currentSchema = nextMantra.index;
      currentMantraIndex = nextMantra.index; // Keep in sync
      saveMantraSelection(currentSchema);

      // Apply background gradient for new schema
      if (schemas[currentSchema] && schemas[currentSchema].backgroundGradient) {
        applyBackgroundGradient(schemas[currentSchema].backgroundGradient);
      } else {
        applyBackgroundGradient(null);
      }

      // Update visualization for new schema
      updateStyle3Mantra();

      // Update dropdown arrow color to match TAM color
      const dropdownArrow = document.querySelector('.dropdown-arrow');
      if (dropdownArrow && schemas[currentSchema] && schemas[currentSchema].tamColor) {
        dropdownArrow.style.borderTopColor = schemas[currentSchema].tamColor;
      }

      // Update navigation button colors
      updateNavButtonColors();

      // Update moon disc outline color
      updateMoonDiscOutlineColor();

      // Update dropdown label
      const dropdownLabel = document.querySelector('.dropdown-label');
      if (dropdownLabel) {
        dropdownLabel.textContent = schemas[currentSchema].name;
      }

      // Update selected state in dropdown
      const dropdownOptions = document.querySelectorAll('.dropdown-option');
      dropdownOptions.forEach(opt => {
        if (parseInt(opt.dataset.value) === currentSchema) {
          opt.classList.add('selected');
        } else {
          opt.classList.remove('selected');
        }
      });

      updateAudioInfo();

      // Stop current audio when switching
      if (isPlaying) {
        togglePlayPause();
      }
    }

    // Navigation functions (for compatibility)
    function prevMantra() {
      navigateToMantra('prev');
    }

    function nextMantra() {
      navigateToMantra('next');
    }

    // Global variables for UI controls
    // Load saved mantra selection or default to 0
    let currentSchema = parseInt(localStorage.getItem('mantraSelection_index2') || '0');
    let audio = new Audio();
    let isPlaying = false;
    // Load saved speed level or default to 2
    let speedLevel = parseInt(localStorage.getItem('mantraSpeedLevel') || '2');
    let rotationSpeed = 0.128 * speedLevel * speedLevel; // Calculate initial rotation speed

    // Camera position adjustments based on orientation
    function getCameraPosition() {
      const isPortrait = window.innerHeight > window.innerWidth;
      const isLandscapeMobile = window.innerHeight < 500 && window.innerWidth > window.innerHeight;
      const isDesktop = window.innerWidth >= 768 && !isPortrait && !isLandscapeMobile;

      if (isLandscapeMobile) {
        return { x: 0, y: 1.8, z: 6.5 };
      } else if (isPortrait) {
        return { x: 0, y: 1.2, z: 9 };
      } else if (isDesktop) {
        return { x: 0, y: 2.2, z: 7 };
      } else {
        return { x: 0, y: 2.2, z: 7 };
      }
    }

    // Helper function to validate and get a valid mantra index
    function getValidMantraIndex(savedIndex) {
      // Ensure index is within bounds
      if (savedIndex < 0 || savedIndex >= schemas.length) {
        return 0;
      }
      
      // Check if the mantra at this index is released
      if (!isMantraReleased(schemas[savedIndex])) {
        // Find first released mantra
        const firstReleased = schemas.findIndex(schema => isMantraReleased(schema));
        return firstReleased >= 0 ? firstReleased : 0;
      }
      
      return savedIndex;
    }

    // Helper function to save mantra selection
    function saveMantraSelection(index) {
      localStorage.setItem('mantraSelection_index2', index.toString());
    }

    // Initialize all visualizations
    async function init() {
      // Load mantras configuration first
      await loadMantrasConfig();

      // Validate and set current schema from localStorage
      currentSchema = getValidMantraIndex(currentSchema);
      currentMantraIndex = currentSchema; // Keep in sync

      // Apply initial background gradient
      if (schemas[currentSchema] && schemas[currentSchema].backgroundGradient) {
        applyBackgroundGradient(schemas[currentSchema].backgroundGradient);
      }

      // Populate dropdown with loaded mantras
      populateDropdown();

      // Set initial nav button colors
      updateNavButtonColors();

      // Set initial moon disc outline color
      updateMoonDiscOutlineColor();

      // Initialize Style 3 (main visualization)
      await initStyle3();

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('orientationchange', onOrientationChange);

      // Custom dropdown functionality
      const dropdownTrigger = document.querySelector('.dropdown-trigger');
      const dropdownMenu = document.querySelector('.dropdown-menu');
      const dropdownLabel = document.querySelector('.dropdown-label');

      // Set initial dropdown arrow color to match TAM color
      const dropdownArrow = document.querySelector('.dropdown-arrow');
      if (dropdownArrow && schemas[currentSchema] && schemas[currentSchema].tamColor) {
        dropdownArrow.style.borderTopColor = schemas[currentSchema].tamColor;
      }

      dropdownTrigger.addEventListener('click', () => {
        dropdownTrigger.classList.toggle('active');
        dropdownMenu.classList.toggle('show');
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.custom-dropdown')) {
          dropdownTrigger.classList.remove('active');
          dropdownMenu.classList.remove('show');
        }
      });

      // Use event delegation for dynamically created options
      dropdownMenu.addEventListener('click', (e) => {
        const option = e.target.closest('.dropdown-option');
        if (!option) return;

        const value = parseInt(option.dataset.value);
        const text = option.textContent;

        // Update selected state
        dropdownMenu.querySelectorAll('.dropdown-option').forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');

        // Update trigger label
        dropdownLabel.textContent = text;

        // Close dropdown
        dropdownTrigger.classList.remove('active');
        dropdownMenu.classList.remove('show');

        // Update schema
        currentSchema = value;
        currentMantraIndex = value; // Keep in sync
        saveMantraSelection(currentSchema);

        // Apply background gradient for new schema
        if (schemas[currentSchema] && schemas[currentSchema].backgroundGradient) {
          applyBackgroundGradient(schemas[currentSchema].backgroundGradient);
        } else {
          applyBackgroundGradient(null);
        }

        // Update visualization for new schema
        updateStyle3Mantra();

        // Update dropdown arrow color to match TAM color
        if (dropdownArrow && schemas[currentSchema] && schemas[currentSchema].tamColor) {
          dropdownArrow.style.borderTopColor = schemas[currentSchema].tamColor;
        }

        // Update navigation button colors
        updateNavButtonColors();

        // Update moon disc outline color
        updateMoonDiscOutlineColor();

        updateAudioInfo();

        // Stop current audio when switching
        if (isPlaying) {
          togglePlayPause();
        }
      });

      // Audio controls
      const playPauseBtn = document.getElementById('play-pause-btn');
      playPauseBtn.addEventListener('click', togglePlayPause);

      audio.addEventListener('ended', () => {
        isPlaying = false;
        playPauseBtn.textContent = '▶';
        document.getElementById('audio-status').textContent = 'Ended';
      });

      audio.addEventListener('error', (e) => {
        const audioStatus = document.getElementById('audio-status');
        if (audioStatus) {
          audioStatus.textContent = 'Audio unavailable';
        }
        const audioControls = document.getElementById('audio-controls');
        if (audioControls) {
          audioControls.style.display = 'none';
        }
      });

      audio.addEventListener('canplay', () => {
        if (!isPlaying) {
          document.getElementById('audio-status').textContent = 'Ready to play';
        }
      });

      // Initialize audio
      updateAudioInfo();

      // Fullscreen toggle
      const fullscreenToggle = document.getElementById('fullscreen-toggle');
      const fullscreenEnter = document.querySelector('.fullscreen-enter');
      const fullscreenExit = document.querySelector('.fullscreen-exit');

      // Hide fullscreen button if running as PWA (standalone mode) or if fullscreen API not supported
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
        window.navigator.standalone ||
        document.referrer.includes('android-app://');

      const supportsFullscreen = document.documentElement.requestFullscreen ||
        document.documentElement.webkitRequestFullscreen ||
        document.documentElement.mozRequestFullScreen ||
        document.documentElement.msRequestFullscreen;

      // Hide button if in standalone mode OR if fullscreen not supported (like iOS Safari)
      if (isStandalone || (!supportsFullscreen && /iPad|iPhone|iPod/.test(navigator.userAgent))) {
        fullscreenToggle.style.display = 'none';
      }

      function updateFullscreenIcon() {
        const isFullscreen = document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement;

        if (isFullscreen) {
          fullscreenEnter.style.display = 'none';
          fullscreenExit.style.display = 'block';
        } else {
          fullscreenEnter.style.display = 'block';
          fullscreenExit.style.display = 'none';
        }
      }

      fullscreenToggle.addEventListener('click', () => {
        if (!document.fullscreenElement &&
          !document.webkitFullscreenElement &&
          !document.mozFullScreenElement &&
          !document.msFullscreenElement) {
          // Enter fullscreen
          const elem = document.documentElement;

          if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => {
              console.log('Fullscreen request failed:', err);
              alert('Fullscreen mode is not available. On iOS, tap the Share button and select "Add to Home Screen" for a fullscreen experience.');
            });
          } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
          } else if (elem.webkitEnterFullscreen) {
            elem.webkitEnterFullscreen();
          } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
          } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
          } else {
            alert('Fullscreen mode is not available on this device. On iOS, tap the Share button and select "Add to Home Screen" for a fullscreen experience.');
          }
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      });

      // Listen for fullscreen changes (including ESC key)
      document.addEventListener('fullscreenchange', updateFullscreenIcon);
      document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
      document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
      document.addEventListener('MSFullscreenChange', updateFullscreenIcon);

      // Speed controls
      const speedDecreaseBtn = document.getElementById('speed-decrease');
      const speedIncreaseBtn = document.getElementById('speed-increase');
      const speedValueDisplay = document.getElementById('speed-value');

      function updateSpeedDisplay() {
        speedValueDisplay.textContent = speedLevel;
      }

      function updateRotationSpeed() {
        // Quadratic curve: 0.128 * level^2
        rotationSpeed = 0.128 * speedLevel * speedLevel;
        if (style3Controls) {
          style3Controls.autoRotateSpeed = rotationSpeed;
        }
        updateSpeedDisplay();
        localStorage.setItem('mantraSpeedLevel', speedLevel);
      }

      // Initialize display
      updateSpeedDisplay();

      speedDecreaseBtn.addEventListener('click', () => {
        if (speedLevel > 0) {
          speedLevel--;
          updateRotationSpeed();
        }
      });

      speedIncreaseBtn.addEventListener('click', () => {
        if (speedLevel < 10) {
          speedLevel++;
          updateRotationSpeed();
        }
      });

      // Navigation controls
      const navPrevBtn = document.getElementById('nav-prev');
      const navNextBtn = document.getElementById('nav-next');

      navPrevBtn.addEventListener('click', () => navigateToMantra('prev'));
      navNextBtn.addEventListener('click', () => navigateToMantra('next'));

      // Setup keyboard shortcuts for navigation
      document.addEventListener('keydown', (e) => {
        // Only handle arrow keys if not typing in an input/textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }
        
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          navigateToMantra('prev');
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          navigateToMantra('next');
        }
      });

      // Auto-hide controls on desktop (desktop only)
      setupAutoHideControls();

      console.log('Initialization complete');
    }

    function togglePlayPause() {
      const schema = schemas[currentSchema];
      const playPauseBtn = document.getElementById('play-pause-btn');
      const audioStatus = document.getElementById('audio-status');

      // Check if audio file is available
      if (!schema.audioFile || !audio.src) {
        audioStatus.textContent = 'No audio available';
        return;
      }

      if (isPlaying) {
        audio.pause();
        playPauseBtn.textContent = '▶';
        audioStatus.textContent = 'Paused';
        isPlaying = false;
      } else {
        audio.play().then(() => {
          playPauseBtn.textContent = '⏸';
          audioStatus.textContent = 'Playing';
          isPlaying = true;
        }).catch(err => {
          audioStatus.textContent = 'Audio unavailable';
          const audioControls = document.getElementById('audio-controls');
          if (audioControls) {
            audioControls.style.display = 'none';
          }
        });
      }
    }

    function updateAudioInfo() {
      const schema = schemas[currentSchema];
      const audioControls = document.getElementById('audio-controls');
      const audioTitle = document.getElementById('audio-title');
      const audioStatus = document.getElementById('audio-status');

      // Check if audio file is defined
      if (schema.audioFile) {
        audioTitle.textContent = schema.name;
        audioStatus.textContent = 'Ready to play';
        audio.src = schema.audioFile;
        audio.load();
      } else {
        audioControls.style.display = 'none';
        audio.src = '';
        audioStatus.textContent = 'No audio available';
      }
    }

    // Auto-hide controls functionality (desktop only)
    function setupAutoHideControls() {
      const isDesktop = () => window.innerWidth >= 769;
      
      if (!isDesktop()) {
        return;
      }

      const speedControls = document.getElementById('speed-controls');
      const navControls = document.getElementById('nav-controls');
      
      if (!speedControls || !navControls) {
        return;
      }

      let hideTimeout = null;
      let mouseMoveTimeout = null;
      const HIDE_DELAY = 3000;
      const MOUSE_STOP_DELAY = 2000;
      const INITIAL_HIDE_DELAY = 3000;

      function showControls() {
        speedControls.classList.remove('controls-hidden');
        navControls.classList.remove('controls-hidden');
      }

      function hideControls() {
        speedControls.classList.add('controls-hidden');
        navControls.classList.add('controls-hidden');
      }

      function clearAllTimeouts() {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        if (mouseMoveTimeout) {
          clearTimeout(mouseMoveTimeout);
          mouseMoveTimeout = null;
        }
      }

      // Check if mouse is over any UI control element
      function isMouseOverControls(e) {
        const target = e.target;
        return speedControls.contains(target) || 
               navControls.contains(target) ||
               document.getElementById('schema-selector')?.contains(target) ||
               document.getElementById('fullscreen-toggle')?.contains(target) ||
               document.getElementById('mode-controls')?.contains(target) ||
               document.getElementById('audio-controls')?.contains(target);
      }

      function scheduleHide(delay = MOUSE_STOP_DELAY) {
        clearAllTimeouts();
        hideTimeout = setTimeout(() => {
          if (isDesktop()) {
            hideControls();
          }
        }, delay);
      }

      function handleMouseMove(e) {
        if (!isDesktop()) {
          return;
        }

        // If mouse is over controls, show them and don't schedule hide
        if (isMouseOverControls(e)) {
          showControls();
          clearAllTimeouts();
          return;
        }

        showControls();
        clearAllTimeouts();

        mouseMoveTimeout = setTimeout(() => {
          scheduleHide(0);
        }, MOUSE_STOP_DELAY);
      }

      function handleMouseLeave(e) {
        if (!isDesktop()) {
          return;
        }
        
        // Don't hide if mouse is moving to a control element
        if (e.relatedTarget && (isMouseOverControls(e) || 
            speedControls.contains(e.relatedTarget) || 
            navControls.contains(e.relatedTarget))) {
          return;
        }
        
        clearAllTimeouts();
        scheduleHide(0);
      }

      scheduleHide(INITIAL_HIDE_DELAY);

      document.addEventListener('mousemove', handleMouseMove, { passive: true });
      document.addEventListener('mouseleave', handleMouseLeave, { passive: true });

      document.addEventListener('mouseout', (e) => {
        if (!e.relatedTarget && !e.toElement) {
          handleMouseLeave(e);
        }
      }, { passive: true });

      // Keep controls visible when hovering over them
      speedControls.addEventListener('mouseenter', () => {
        showControls();
        clearAllTimeouts();
      });

      navControls.addEventListener('mouseenter', () => {
        showControls();
        clearAllTimeouts();
      });

      // Schedule hide when leaving control areas
      speedControls.addEventListener('mouseleave', (e) => {
        if (!isMouseOverControls(e)) {
          scheduleHide(0);
        }
      });

      navControls.addEventListener('mouseleave', (e) => {
        if (!isMouseOverControls(e)) {
          scheduleHide(0);
        }
      });

      window.addEventListener('resize', () => {
        if (!isDesktop()) {
          clearAllTimeouts();
          showControls();
        } else {
          scheduleHide(INITIAL_HIDE_DELAY);
        }
      }, { passive: true });
    }

    function onWindowResize() {
      if (style3Camera && style3Renderer) {
        style3Camera.aspect = window.innerWidth / window.innerHeight;
        style3Camera.updateProjectionMatrix();
        style3Renderer.setSize(window.innerWidth, window.innerHeight);

        // Adjust camera position based on new dimensions
        const camPos = getCameraPosition();
        style3Camera.position.set(camPos.x, camPos.y, camPos.z);
      }
    }

    function onOrientationChange() {
      setTimeout(() => {
        onWindowResize();
      }, 100);
    }

    init();
  </script>
</body>

</html>