<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Mantra Visualization</title>

  <!-- PWA / iOS fullscreen support -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Noto+Sans:wght@400;600;700&display=swap"
    rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Magical sparkle animation for background */
    @keyframes rainbowSparkle {
      0%, 100% { 
        filter: brightness(1.0) saturate(1.0);
      }
      25% { 
        filter: brightness(1.02) saturate(1.03);
      }
      50% { 
        filter: brightness(1.0) saturate(1.01);
      }
      75% { 
        filter: brightness(1.01) saturate(1.0);
      }
    }
    
    /* Gentle rotation for the rainbow rays */
    @keyframes rainbowSpin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
      /* Base background color */
      background: #f4f0f8;
      overflow: hidden;
      touch-action: none;
      position: relative;
    }
    
    /* Spinning rainbow rays layer */
    .rainbow-spin {
      position: fixed;
      /* Make it larger than viewport to avoid corners showing during rotation */
      width: 200vmax;
      height: 200vmax;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* Rainbow rays conic gradient - 6 repetitions (60deg each) */
      background: repeating-conic-gradient(from 0deg at 50% 50%,
        #edd8f5 0deg,
        #d8edf5 7.5deg,
        #d8f5e0 15deg,
        #f5efd8 22.5deg,
        #f5ddd8 30deg,
        #ecd8f5 37.5deg,
        #d8d8f5 45deg,
        #d8ecf5 52.5deg,
        #edd8f5 60deg
      );
      pointer-events: none;
      z-index: -2;
      animation: rainbowSpin 600s linear infinite, rainbowSparkle 8s ease-in-out infinite;
    }
    
    /* White center fade overlay (static, doesn't spin) */
    .rainbow-center-fade {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 50% 50%,
        rgba(255, 255, 255, 1) 0%,
        rgba(255, 255, 255, 0.85) 4%,
        rgba(255, 255, 255, 0.5) 8%,
        rgba(255, 255, 255, 0.2) 12%,
        rgba(255, 255, 255, 0) 18%
      );
      pointer-events: none;
      z-index: -1;
    }
    
    /* Subtle dither/grain texture for natural look */
    .dither-texture {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      opacity: 0.5;
      mix-blend-mode: overlay;
      /* Radial mask - less grain in center, more at edges */
      -webkit-mask-image: radial-gradient(circle at 50% 50%, transparent 0%, rgba(0,0,0,0.3) 20%, rgba(0,0,0,1) 50%);
      mask-image: radial-gradient(circle at 50% 50%, transparent 0%, rgba(0,0,0,0.3) 20%, rgba(0,0,0,1) 50%);
    }
    
    /* Sparkle overlay for magical twinkle effect */
    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 200%;
      height: 200%;
      background: 
        radial-gradient(circle at 20% 30%, rgba(255,255,255,0.3) 0%, transparent 1%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,0.25) 0%, transparent 0.8%),
        radial-gradient(circle at 40% 70%, rgba(255,255,255,0.2) 0%, transparent 1.2%),
        radial-gradient(circle at 65% 85%, rgba(255,255,255,0.3) 0%, transparent 0.6%),
        radial-gradient(circle at 10% 60%, rgba(255,255,255,0.2) 0%, transparent 0.9%),
        radial-gradient(circle at 90% 50%, rgba(255,255,255,0.25) 0%, transparent 1%),
        radial-gradient(circle at 30% 10%, rgba(255,255,255,0.15) 0%, transparent 0.7%),
        radial-gradient(circle at 55% 40%, rgba(255,255,255,0.2) 0%, transparent 1.1%);
      background-size: 400px 400px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.15;
      animation: sparkleMove 20s linear infinite;
    }
    
    @keyframes sparkleMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(-50%, -50%); }
    }

    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;

      /* Use mask to allow color control via background-color */
      /* Opacity is dynamically controlled via injected style element */
      /* Start with very low opacity, will fade in to final opacity */
      background-color: rgba(255, 255, 255, 0.005);
      -webkit-mask-image: url('images/pattern.svg');
      mask-image: url('images/pattern.svg');
      -webkit-mask-size: 80px 80px;
      mask-size: 80px 80px;
      -webkit-mask-repeat: repeat;
      mask-repeat: repeat;

      /* Subtle highlight effect - soft glow */
      filter: brightness(1.1) drop-shadow(0 0 1px rgba(255, 255, 255, 0.4));
      -webkit-filter: brightness(1.1) drop-shadow(0 0 1px rgba(255, 255, 255, 0.4));

      pointer-events: none;
      z-index: 0;
      transition: background-color 2s ease-in-out;
    }

    /* Desktop: larger background pattern */
    @media (min-width: 769px) {
      body::before {
        -webkit-mask-size: 80px 80px;
        mask-size: 80px 80px;
      }
    }

    /* Mobile landscape: scale down background pattern */
    @media (max-width: 768px) and (orientation: landscape) {
      body::before {
        -webkit-mask-size: 20px 20px;
        mask-size: 20px 20px;
      }
    }

    /* Mobile portrait: larger background pattern */
    @media (max-width: 768px) and (orientation: portrait) {
      body::before {
        -webkit-mask-size: 50px 50px;
        mask-size: 50px 50px;
      }
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
      z-index: 2;
    }

    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1;
      background:
        linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%),
        linear-gradient(to left, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%),
        linear-gradient(to top, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%),
        linear-gradient(to right, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 3%, rgba(0, 0, 0, 0.06) 6%, rgba(0, 0, 0, 0.02) 8%, transparent 10%);
      background-size: 100% 10%, 10% 100%, 100% 10%, 10% 100%;
      background-position: top, right, bottom, left;
      background-repeat: no-repeat;
      transition: background 0.5s ease;
    }

    /* Custom dropdown - Light theme */
    #schema-selector {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 20;
      transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
      opacity: 1;
      visibility: visible;
    }

    /* Desktop only: hide controls when inactive */
    @media (min-width: 769px) {
      #schema-selector.controls-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
    }

    .custom-dropdown {
      position: relative;
      min-width: 340px;
      z-index: 20;
    }

    .dropdown-trigger {
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: none;
      border-radius: 10px;
      color: #2d1b4e;
      font-family: "Noto Sans", sans-serif;
      font-size: 16px;
      font-weight: 400;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      transition: box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1), border-radius 0.2s ease 0.25s;
      user-select: none;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.18);
    }

    .dropdown-label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      min-width: 0;
    }

    .dropdown-trigger:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .dropdown-trigger.active {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      transition: box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 6px solid rgba(45, 27, 78, 0.7);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .dropdown-trigger.active .dropdown-arrow {
      transform: rotate(180deg);
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: none;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
      z-index: 21;
    }

    .custom-dropdown:hover .dropdown-menu.show {
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    .dropdown-menu.show {
      max-height: 500px;
      opacity: 1;
      pointer-events: all;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .dropdown-option {
      padding: 16px 26px;
      color: rgba(45, 27, 78, 0.85);
      font-family: "Noto Sans", sans-serif;
      font-size: 16px;
      font-weight: 400;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
      position: relative;
      background: transparent;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dropdown-option:first-child {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    }

    .dropdown-menu:not(.show) .dropdown-option:first-child {
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      transition: border-radius 0.2s ease 0.15s;
    }

    .dropdown-option:hover {
      color: rgba(45, 27, 78, 1);
      border-left-color: rgba(45, 27, 78, 0.5);
      background: var(--dropdown-hover-bg, rgba(240, 235, 255, 0.5));
    }

    .dropdown-option.selected {
      color: rgba(45, 27, 78, 1);
      border-left-color: rgba(45, 27, 78, 0.5);
      background: var(--dropdown-selected-bg, rgba(230, 220, 250, 0.4));
    }

    /* Speed controls - Light theme */
    #speed-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      border: 0.5px solid rgba(200, 200, 200, 0.3);
      backdrop-filter: blur(30px);
      transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
      opacity: 1;
      visibility: visible;
    }

    /* Desktop only: hide controls when inactive */
    @media (min-width: 769px) {
      #speed-controls.controls-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
    }

    #speed-controls:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(200, 200, 200, 0.5);
    }

    .speed-btn {
      padding: 8px 14px;
      border-radius: 50px;
      background: transparent;
      border: 1px solid transparent;
      color: rgba(45, 27, 78, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Noto Sans", sans-serif;
      font-size: 15px;
      font-weight: 400;
      user-select: none;
      line-height: 1;
      min-width: 36px;
    }

    .speed-btn:hover {
      color: rgba(45, 27, 78, 0.9);
      background: rgba(200, 190, 230, 0.3);
      transform: none;
    }

    .speed-btn:active {
      transform: scale(0.95);
      background: rgba(200, 190, 230, 0.5);
    }

    #speed-label {
      color: rgba(45, 27, 78, 0.8);
      font-size: 13px;
      min-width: 65px;
      text-align: center;
      font-family: "Noto Sans", sans-serif;
      font-weight: 400;
      padding: 0 4px;
    }

    #speed-value {
      color: rgba(45, 27, 78, 1);
      font-weight: 600;
    }

    /* Mode controls - Light theme */
    #mode-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      border: 0.5px solid rgba(200, 200, 200, 0.3);
    }

    .mode-btn {
      padding: 10px 24px;
      border-radius: 50px;
      background: transparent;
      border: 1px solid rgba(120, 100, 180, 0);
      color: rgba(45, 27, 78, 0.6);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Noto Sans", sans-serif;
      font-size: 16px;
      font-weight: 400;
      user-select: none;
      flex: 1;
      min-width: 0;
      text-align: center;
      box-shadow: none;
    }

    .mode-btn:hover {
      color: rgba(45, 27, 78, 0.8);
    }

    .mode-btn.active {
      background: rgba(200, 190, 230, 0.6);
      border: 1px solid rgba(120, 100, 180, 0.5);
      color: rgba(45, 27, 78, 0.9);
      box-shadow: none;
    }

    .mode-btn:active {
      transform: scale(0.98);
    }

    /* Fullscreen toggle - Light theme */
    #fullscreen-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: 0.5px solid rgba(102, 126, 234, 0.3);
      backdrop-filter: blur(30px);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out, all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 0.7;
      visibility: visible;
    }

    /* Desktop only: hide controls when inactive */
    @media (min-width: 769px) {
      #fullscreen-toggle.controls-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
    }

    #fullscreen-toggle:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.7);
      border-color: rgba(102, 126, 234, 0.5);
      transform: scale(1.05);
    }

    #fullscreen-toggle:active {
      transform: scale(0.95);
    }

    #fullscreen-toggle svg {
      width: 18px;
      height: 18px;
      stroke: rgba(45, 27, 78, 0.8);
      stroke-width: 2;
      fill: none;
    }

    /* Navigation controls - Light theme */
    #nav-controls {
      position: absolute;
      bottom: 30px;
      left: 20px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      border: 0.5px solid rgba(200, 200, 200, 0.3);
      backdrop-filter: blur(30px);
      transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
      opacity: 1;
      visibility: visible;
    }

    /* Desktop only: hide controls when inactive */
    @media (min-width: 769px) {
      #nav-controls.controls-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
    }

    #nav-controls:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(200, 200, 200, 0.5);
    }

    .nav-btn {
      padding: 8px 14px;
      border-radius: 50px;
      background: transparent;
      border: 1px solid transparent;
      color: rgba(45, 27, 78, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Noto Sans", sans-serif;
      font-size: 15px;
      font-weight: 400;
      user-select: none;
      line-height: 1;
      min-width: 36px;
    }

    .nav-btn:hover {
      background: rgba(200, 190, 230, 0.3);
      transform: none;
    }

    .nav-btn:active {
      transform: scale(0.95);
      background: rgba(200, 190, 230, 0.5);
    }

    .nav-btn svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: none;
    }

    /* Audio controls */
    #audio-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 20px;
      border-radius: 50px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      display: none;
      /* Disabled for now */
      align-items: center;
      gap: 12px;
    }

    #play-pause-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(100, 150, 255, 0.3);
      border: 2px solid rgba(100, 150, 255, 0.8);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      font-size: 20px;
    }

    #play-pause-btn:hover {
      background: rgba(100, 150, 255, 0.5);
      transform: scale(1.05);
    }

    #play-pause-btn:active {
      transform: scale(0.95);
    }

    #audio-info {
      color: white;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #audio-status {
      opacity: 0.7;
      font-size: 11px;
    }

    .hidden {
      display: none !important;
    }


    /* Mobile optimizations */
    @media (max-width: 768px) {
      .custom-dropdown {
        min-width: 300px;
      }

      .dropdown-trigger,
      .dropdown-option {
        font-size: 16px;
        padding: 14px 18px;
      }

      #fullscreen-toggle {
        top: 15px;
        right: 15px;
        width: 38px;
        height: 38px;
      }

      #fullscreen-toggle svg {
        width: 16px;
        height: 16px;
      }

      #audio-controls {
        bottom: 20px;
        padding: 10px 16px;
      }

      #play-pause-btn {
        width: 42px;
        height: 42px;
        font-size: 18px;
      }

      #audio-info {
        font-size: 12px;
      }
    }

    /* Portrait mobile - compact UI */
    @media (max-width: 768px) and (orientation: portrait) {
      #schema-selector {
        top: 18px;
        left: 10px;
        right: 10px;
        width: auto;
      }

      .custom-dropdown {
        width: 100%;
        min-width: 0;
      }

      .dropdown-trigger,
      .dropdown-option {
        font-size: 15px;
        padding: 12px 16px;
      }

      #fullscreen-toggle {
        display: none;
      }

      /* Navigation controls - bottom left */
      #nav-controls {
        bottom: 32px;
        left: 20px;
        right: auto;
        transform: none;
      }

      /* Speed controls - bottom right */
      #speed-controls {
        bottom: 32px;
        left: auto;
        right: 20px;
        transform: none;
      }

      #audio-controls {
        bottom: 15px;
        padding: 8px 12px;
        gap: 8px;
      }

      #play-pause-btn {
        width: 38px;
        height: 38px;
        font-size: 16px;
      }

      #audio-info {
        font-size: 11px;
        max-width: 150px;
      }

      .dropdown-menu.show {
        max-height: 400px;
      }
    }

    /* Landscape mobile - more compact */
    @media (max-height: 500px) and (orientation: landscape) {
      #schema-selector {
        top: 8px;
        left: 8px;
      }

      .custom-dropdown {
        min-width: 300px;
      }

      .dropdown-trigger,
      .dropdown-option {
        font-size: 14px;
        padding: 10px 14px;
      }

      #fullscreen-toggle {
        top: 8px;
        right: 8px;
        width: 32px;
        height: 32px;
      }

      #fullscreen-toggle svg {
        width: 14px;
        height: 14px;
      }

      #speed-controls {
        bottom: auto;
        left: auto;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        flex-direction: column;
        padding: 6px;
        gap: 4px;
      }

      /* Flip order in landscape mobile: plus on top, minus on bottom */
      #speed-increase {
        order: 1;
      }

      #speed-label {
        order: 2;
      }

      #speed-decrease {
        order: 3;
      }

      .speed-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
        padding: 6px;
      }

      #speed-label {
        font-size: 12px;
        min-width: auto;
        writing-mode: horizontal-tb;
        text-orientation: initial;
        transform: none;
        font-size: 0;
      }

      #speed-value {
        font-size: 12px;
      }

      #audio-controls {
        bottom: 10px;
        padding: 6px 10px;
        gap: 6px;
      }

      #play-pause-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      #audio-info {
        font-size: 10px;
        max-width: 120px;
      }

      #audio-status {
        display: none;
      }

      /* Mode controls - Right side for landscape mobile */
      #mode-controls {
        bottom: auto;
        left: auto;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        flex-direction: column;
        padding: 0;
        gap: 4px;
        background: transparent;
        border: none;
        box-shadow: none;
        border-radius: 0;
      }

      .mode-btn {
        background: rgba(255, 255, 255, 0.4);
        border: 1px solid rgba(200, 200, 200, 0.2);
        border-radius: 50px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        min-width: 0;
        width: 100%;
      }

      .mode-btn.active {
        background: rgba(255, 255, 255, 0.85);
        border: 1px solid rgba(200, 200, 200, 0.3);
      }

      .mode-btn:active {
        transform: none;
      }

      /* Navigation controls - Middle left for landscape mobile */
      #nav-controls {
        bottom: auto;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        flex-direction: column;
        padding: 6px;
        gap: 4px;
      }

      .nav-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        font-size: 14px;
      }

      .dropdown-menu.show {
        max-height: calc(100vh - 120px);
      }

    }
  </style>
</head>

<body>
  <!-- SVG noise filter for subtle dither texture -->
  <svg style="position: absolute; width: 0; height: 0;">
    <filter id="grain">
      <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch" result="noise"/>
      <feColorMatrix type="saturate" values="0"/>
    </filter>
  </svg>
  
  <div class="rainbow-spin"></div>
  <div class="rainbow-center-fade"></div>
  <div class="dither-texture" style="filter: url(#grain);"></div>
  <div id="vignette"></div>
  <div id="container"></div>



  <div id="schema-selector">
    <div class="custom-dropdown">
      <div class="dropdown-trigger">
        <span class="dropdown-label">Tara Vajra Sarasvati</span>
        <div class="dropdown-arrow"></div>
      </div>
      <div class="dropdown-menu">
        <!-- Options will be populated dynamically from mantras.json -->
      </div>
    </div>
  </div>

  <button id="fullscreen-toggle" aria-label="Toggle fullscreen">
    <svg viewBox="0 0 24 24">
      <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
        class="fullscreen-enter" />
      <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"
        class="fullscreen-exit" style="display:none;" />
    </svg>
  </button>

  <div id="mode-controls" style="display: none;">
    <button class="mode-btn active" id="mode-ring" aria-label="Ring mode">Ring</button>
    <button class="mode-btn" id="mode-billboard" aria-label="Billboard mode">Flat</button>
  </div>

  <div id="speed-controls">
    <button class="speed-btn" id="speed-decrease" aria-label="Decrease speed">−</button>
    <div id="speed-label">Speed: <span id="speed-value">1.0×</span></div>
    <button class="speed-btn" id="speed-increase" aria-label="Increase speed">+</button>
  </div>

  <div id="nav-controls">
    <button class="nav-btn" id="nav-prev" aria-label="Previous mantra">
      <svg viewBox="0 0 24 24">
        <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"
          stroke-linejoin="round" />
      </svg>
    </button>
    <button class="nav-btn" id="nav-next" aria-label="Next mantra">
      <svg viewBox="0 0 24 24">
        <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"
          stroke-linejoin="round" />
      </svg>
    </button>
  </div>

  <div id="audio-controls">
    <button id="play-pause-btn" aria-label="Play/Pause">▶</button>
    <div id="audio-info">
      <div id="audio-title">Tara Vajra Sarasvati</div>
      <div id="audio-status">Ready to play</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

    // Schema definitions - loaded from JSON config
    let schemas = [];

    // Load mantras configuration from local JSON file
    async function loadMantrasConfig() {
      try {
        const response = await fetch(`mantras.json?t=${Date.now()}`, {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
          }
        });

        const config = await response.json();

        // Process schemas: convert outlineColor string to number, ensure defaults
        schemas = config.mantras.map(mantra => {
          let outlineColor = null;
          if (mantra.outlineColor) {
            // Handle both "0x1a3a5c" and "#1a3a5c" formats
            const colorStr = String(mantra.outlineColor).replace(/^#/, '').replace(/^0x/i, '');
            outlineColor = parseInt(colorStr, 16);
          }

          // Process syllableStyle if present
          let syllableStyle = null;
          if (mantra.syllableStyle) {
            const style = mantra.syllableStyle;
            syllableStyle = {
              fill: style.fill || '#ffffff',  // Keep as hex string for Canvas API
              outlineColor: style.outlineColor || '#000000',  // Keep as hex string for Canvas API
              outlineWidth: style.outlineWidth || 0
            };
          }

          return {
            name: mantra.name,
            syllables: mantra.syllables,
            audioFile: mantra.audioFile || null, // Optional - may be undefined
            syllables: mantra.syllables,
            tamColor: mantra.tamColor || '#ffffff',
            tamOutlineColor: mantra.tamOutlineColor || null,
            orbColor: mantra.orbColor || null, // New: orb color for sphere gradient
            outlineColor: outlineColor,
            syllableStyle: syllableStyle,
            backgroundGradient: mantra.backgroundGradient || null,
            patternOpacity: mantra.patternOpacity !== undefined ? mantra.patternOpacity : null, // Optional override
            startIndex: mantra.startIndex || 0,
            releaseDate: mantra.releaseDate || "",
            releaseDateOverride: mantra.releaseDateOverride || false
          };
        });

        console.log('Loaded mantras configuration:', schemas);



        return schemas;
      } catch (error) {
        console.error('Failed to load mantras.json, using fallback:', error);
        // Fallback to default configuration
        schemas = [
          {
            name: "Tara Vajra Sarasvati",
            syllables: ["OM", "TA", "RE", "TU", "TA", "RE", "TU", "RE", "PRA", "JNA", "HRING", "HRING", "SVA", "HA"],
            syllables: ["OṂ", "TĀ", "RE", "TU", "TTĀ", "RE", "TU", "RE", "PRA", "JÑĀ", "HRĪṂ", "HRĪṂ", "SVĀ", "HĀ"],
            outlineColor: 0x1a3a5c,
            syllableStyle: null,
            backgroundGradient: null,
            startIndex: 0
          },
          {
            name: "Om Mani Padme Hum",
            syllables: ["OM", "MA", "NI", "PAD", "ME", "HUM"],
            syllables: ["OṂ", "TĀ", "RE", "TU", "TTĀ", "RE", "TU", "RE", "MA", "MA", "Ā", "YUR", "PU", "NYE", "JNĀ", "NA", "PU", "SHTIM", "KU", "RU", "SVĀ", "HĀ"],
            outlineColor: null,
            syllableStyle: null,
            backgroundGradient: null,
            startIndex: 0
          },
          {
            name: "Simple Om",
            syllables: ["OM", "OM"],
            syllables: ["OṂ", "TĀ", "RE", "TU", "TTĀ", "RE", "TU", "RE", "MA", "MA", "Ā", "YUR", "PU", "NYE", "JNĀ", "NA", "PU", "SHTIM", "KU", "RU", "SVĀ", "HĀ"],
            outlineColor: null,
            syllableStyle: null,
            backgroundGradient: null,
            startIndex: 0
          }
        ];
        return schemas;
      }
    }

    // Helper function to darken a hex color
    function darkenColor(hex, amount) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      // Darken by reducing each component
      const newR = Math.max(0, Math.floor(r * (1 - amount)));
      const newG = Math.max(0, Math.floor(g * (1 - amount)));
      const newB = Math.max(0, Math.floor(b * (1 - amount)));

      // Convert back to hex
      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }

    // Helper function to create a pastel version of a hex color
    function pastelizeColor(hex, whiteMix = 0.7) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      // Mix with white to create pastel effect (higher whiteMix = more pastel)
      const newR = Math.min(255, Math.floor(r * (1 - whiteMix) + 255 * whiteMix));
      const newG = Math.min(255, Math.floor(g * (1 - whiteMix) + 255 * whiteMix));
      const newB = Math.min(255, Math.floor(b * (1 - whiteMix) + 255 * whiteMix));

      // Convert back to hex
      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }

    // Helper function to calculate luminance from hex color
    function getColorLuminance(hexColor) {
      // Remove # if present
      const hex = hexColor.replace('#', '');

      // Parse RGB
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;

      // Calculate relative luminance (ITU-R BT.709)
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    // Helper function to calculate average luminance from gradient
    function getGradientAverageLuminance(gradientConfig) {
      if (!gradientConfig || !gradientConfig.colors || gradientConfig.colors.length === 0) {
        // Default gradient - return average luminance of default colors
        const defaultColors = ['#f0e0ff', '#e0f0ff', '#e0ffe0', '#fff8e0', '#ffe0e8'];
        const luminances = defaultColors.map(getColorLuminance);
        return luminances.reduce((a, b) => a + b, 0) / luminances.length;
      }

      // Calculate weighted average luminance based on color stops
      const colors = gradientConfig.colors;
      let totalWeight = 0;
      let weightedLuminance = 0;

      for (let i = 0; i < colors.length; i++) {
        const color = colors[i];
        const luminance = getColorLuminance(color.color);

        // Calculate weight based on position span
        let weight;
        if (i === 0) {
          weight = color.position / 100;
        } else if (i === colors.length - 1) {
          weight = (100 - colors[i - 1].position) / 100;
        } else {
          weight = (color.position - colors[i - 1].position) / 100;
        }

        weightedLuminance += luminance * weight;
        totalWeight += weight;
      }

      return totalWeight > 0 ? weightedLuminance / totalWeight : 0.5;
    }

    // Calculate pattern opacity based on background luminance
    // Higher luminance (lighter backgrounds) = higher opacity (more visible pattern)
    // Lower luminance (darker backgrounds) = lower opacity (more subtle pattern)
    function calculatePatternOpacity(luminance, overrideOpacity = null) {
      // If override is provided, use it directly
      if (overrideOpacity !== null && overrideOpacity !== undefined) {
        return Math.max(0, Math.min(1, overrideOpacity));
      }

      // Map luminance (0-1) to opacity range (balanced for visibility)
      // Light backgrounds (luminance > 0.7): opacity 0.06-0.08 (more visible)
      // Medium backgrounds (luminance 0.3-0.7): opacity 0.04-0.06 (balanced)
      // Dark backgrounds (luminance < 0.3): opacity 0.02-0.04 (more subtle)

      if (luminance > 0.7) {
        // Light backgrounds: scale from 0.06 to 0.08
        const t = (luminance - 0.7) / 0.3; // Normalize to 0-1
        return 0.06 + (t * 0.02);
      } else if (luminance > 0.3) {
        // Medium backgrounds: scale from 0.04 to 0.06
        const t = (luminance - 0.3) / 0.4; // Normalize to 0-1
        return 0.04 + (t * 0.02);
      } else {
        // Dark backgrounds: scale from 0.02 to 0.04
        const t = luminance / 0.3; // Normalize to 0-1
        return 0.02 + (t * 0.02);
      }
    }

    // Update pattern opacity based on current background
    function updatePatternOpacity(gradientConfig, overrideOpacity = null) {
      const luminance = getGradientAverageLuminance(gradientConfig);
      const opacity = calculatePatternOpacity(luminance, overrideOpacity);

      // Since ::before pseudo-element can't be directly accessed, inject/update a style element
      let patternStyleElement = document.getElementById('dynamic-pattern-opacity');
      if (!patternStyleElement) {
        patternStyleElement = document.createElement('style');
        patternStyleElement.id = 'dynamic-pattern-opacity';
        document.head.appendChild(patternStyleElement);
      }

      // Update the style with the calculated opacity
      patternStyleElement.textContent = `body::before { background-color: rgba(255, 255, 255, ${opacity}); }`;
    }

    // Helper function to get nav button color based on tamColor
    function getNavButtonColor(tamColor) {
      if (!tamColor) {
        return '#2d1b4e'; // Default dark color
      }

      const luminance = getColorLuminance(tamColor);

      // If luminance is high (light color), use dark gray
      // Threshold of 0.8 means very light colors (near white) will be inverted
      if (luminance > 0.8) {
        return '#3a3a3a'; // Dark gray
      }

      return tamColor;
    }

    // Update moon disc outline color - always use gray
    function updateMoonDiscOutlineColor() {
      if (!moonDiscOutlineMat) return;
      moonDiscOutlineMat.color.set('#aaaaaa'); // Gray for all mantras
    }

    // Update navigation button colors based on current mantra
    function updateNavButtonColors() {
      const navButtons = document.querySelectorAll('.nav-btn');
      if (navButtons.length === 0) return;

      const tamColor = schemas[currentSchema]?.tamColor;
      const buttonColor = getNavButtonColor(tamColor);

      navButtons.forEach(btn => {
        btn.style.color = buttonColor;
      });
    }

    // Update dropdown colors based on current mantra's TAM color
    function updateDropdownColors() {
      const tamColor = schemas[currentSchema]?.tamColor || '#ffffff';
      
      // Check if TAM color is white or very light (luminance > 0.9)
      const luminance = getColorLuminance(tamColor);
      let hoverColor, selectedColor;
      
      if (luminance > 0.9) {
        // Use light gray for white/very light TAM colors
        hoverColor = 'rgba(235, 235, 235, 0.5)';
        selectedColor = 'rgba(235, 235, 235, 0.4)';
      } else {
        // Use pastel version of TAM color
        const pastelColor = pastelizeColor(tamColor, 0.7);
        const hex = pastelColor.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        hoverColor = `rgba(${r}, ${g}, ${b}, 0.5)`;
        selectedColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
      }
      
      // Set CSS custom properties for dropdown hover and selected states
      document.documentElement.style.setProperty('--dropdown-hover-bg', hoverColor);
      document.documentElement.style.setProperty('--dropdown-selected-bg', selectedColor);
    }

    // Helper function to extract a representative color from gradient
    function extractColorFromGradient(gradientConfig) {
      if (!gradientConfig || !gradientConfig.colors || gradientConfig.colors.length === 0) {
        // Default background colors - use a representative color from the default gradient
        return '#e0f0ff'; // A light blue from the default gradient
      }

      // For radial gradients, prefer center colors; for linear, use middle colors
      const colors = gradientConfig.colors;

      // Find the color closest to center (position 0% or closest to center)
      let centerColor = colors[0].color;
      let minDistance = Math.abs(colors[0].position - 0);

      for (const colorStop of colors) {
        const distance = Math.abs(colorStop.position - 0);
        if (distance < minDistance) {
          minDistance = distance;
          centerColor = colorStop.color;
        }
      }

      return centerColor;
    }

    // Update vignette based on current background
    function updateVignette(gradientConfig) {
      const vignetteEl = document.getElementById('vignette');
      if (!vignetteEl) return;

      // Extract a representative color from the gradient
      const baseColor = extractColorFromGradient(gradientConfig);

      // Darken the color for the vignette (darken by 70-80% for stronger effect)
      const darkenedColor = darkenColor(baseColor, 0.75);

      // Convert hex to rgba for better control
      const r = parseInt(darkenedColor.substring(1, 3), 16);
      const g = parseInt(darkenedColor.substring(3, 5), 16);
      const b = parseInt(darkenedColor.substring(5, 7), 16);

      // Create vignette that darkens all edges uniformly (not just corners)
      // Use multiple linear gradients - one for each edge
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const maxOpacity = luminance > 0.5 ? 0.85 : 0.75; // Strong opacity at edges
      const midOpacity = maxOpacity * 0.5; // Mid-range opacity for smooth transition

      // Calculate 10% of viewport for edge darkening
      // Use linear gradients for each edge that fade from transparent to dark
      const edgeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.4})`; // Reduced opacity
      const midEdgeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.2})`;
      const fadeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.08})`;
      const veryFadeColor = `rgba(${r}, ${g}, ${b}, ${maxOpacity * 0.03})`;

      // Top edge: softer, more gradual fade (10% coverage)
      const topGradient = `linear-gradient(to bottom, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;
      // Right edge: fade from right
      const rightGradient = `linear-gradient(to left, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;
      // Bottom edge: fade from bottom
      const bottomGradient = `linear-gradient(to top, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;
      // Left edge: fade from left
      const leftGradient = `linear-gradient(to right, ${edgeColor} 0%, ${midEdgeColor} 3%, ${fadeColor} 6%, ${veryFadeColor} 8%, transparent 10%)`;

      // Combine all gradients
      vignetteEl.style.background = `${topGradient}, ${rightGradient}, ${bottomGradient}, ${leftGradient}`;
      vignetteEl.style.backgroundSize = '100% 10%, 10% 100%, 100% 10%, 10% 100%';
      vignetteEl.style.backgroundPosition = 'top, right, bottom, left';
      vignetteEl.style.backgroundRepeat = 'no-repeat';
    }

    // Fixed page background: white center fade over 8 rainbow cycles
    const FIXED_PAGE_BACKGROUND = `
      radial-gradient(circle at 50% 50%,
        rgba(255, 255, 255, 1) 0%,
        rgba(255, 255, 255, 0.9) 5%,
        rgba(255, 255, 255, 0.6) 10%,
        rgba(255, 255, 255, 0.3) 15%,
        rgba(255, 255, 255, 0) 25%
      ),
      repeating-conic-gradient(from 0deg at 50% 50%,
        #f0e8f8 0deg,
        #e8f0f8 5.625deg,
        #e8f8f0 11.25deg,
        #f8f4e8 16.875deg,
        #f8ece8 22.5deg,
        #f4e8f8 28.125deg,
        #e8e8f8 33.75deg,
        #e8f4f8 39.375deg,
        #f0e8f8 45deg
      )`;

    // Apply background gradient - now always uses fixed rainbow, but still updates vignette/pattern/orb
    function applyBackgroundGradient(schema, patternOpacityOverride = null) {
      // Rainbow background is now handled via CSS with spinning animation
      // Don't override body background here
      
      // Still update vignette based on mantra gradient for subtle theming
      const gradientConfig = schema?.backgroundGradient || null;
      updateVignette(gradientConfig);
      
      // Update pattern opacity based on fixed background luminance
      // Use a default light luminance since our fixed background is pastel
      updatePatternOpacity(null, patternOpacityOverride);
      
      // Update orb gradient with mantra's orbColor
      updateOrbGradient(schema);
    }

    // Check for URL parameter to control mantra visibility
    // Default: show all mantras
    // ?releasedonly: only show released mantras (reverts to old behavior)
    // ?showall: show all mantras (kept for backwards compatibility, now default)
    const urlParams = new URLSearchParams(window.location.search);
    const showOnlyReleased = urlParams.has('releasedonly');
    const showAllMantras = !showOnlyReleased; // Show all by default, unless releasedonly flag is set

    // Helper function to check if a mantra should be displayed
    function isMantraReleased(schema) {
      // If showall is true (default, or ?showall flag), show all mantras
      if (showAllMantras) {
        return true;
      }

      // If override is true, always show the mantra
      if (schema.releaseDateOverride === true) {
        return true;
      }

      // If no release date is set, hide the mantra
      if (!schema.releaseDate || schema.releaseDate === '') {
        return false;
      }

      // Check if release date has passed
      const targetDate = new Date(schema.releaseDate);
      const now = new Date();
      targetDate.setHours(0, 0, 0, 0);
      now.setHours(0, 0, 0, 0);

      return now >= targetDate;
    }

    // Populate dropdown with mantras from config
    function populateDropdown() {
      const dropdownMenu = document.querySelector('.dropdown-menu');
      const dropdownLabel = document.querySelector('.dropdown-label');

      // Clear existing options
      dropdownMenu.innerHTML = '';

      // Create options for each mantra that is released
      schemas.forEach((schema, index) => {
        // Only add option if mantra is released
        if (isMantraReleased(schema)) {
          const option = document.createElement('div');
          option.className = `dropdown-option ${index === currentSchema ? 'selected' : ''}`;
          option.textContent = schema.name;
          option.dataset.value = index;
          dropdownMenu.appendChild(option);
        }
      });

      // Set initial label
      if (schemas[currentSchema]) {
        dropdownLabel.textContent = schemas[currentSchema].name;
      }
    }

    let scene, camera, renderer, controls;
    let glowBall, textMeshes = [];
    // Load mantra selection: URL param > localStorage > default 0
    const mantraParam = urlParams.get('mantra');
    let currentSchema = mantraParam !== null
      ? parseInt(mantraParam)
      : parseInt(localStorage.getItem('mantraSelection_index') || '0');
    let audio = new Audio();
    let isPlaying = false;
    let composer;
    // Load saved speed level or default to 2
    let speedLevel = parseInt(localStorage.getItem('mantraSpeedLevel') || '2');
    let rotationSpeed = 0.128 * speedLevel * speedLevel; // Calculate initial rotation speed
    let tamPlane = null; // Reference to TAM character plane
    let moonDisc = null; // Reference to moon disc
    let moonDiscOutline = null; // Reference to moon disc outline ring
    let moonDiscOutlineMat = null; // Reference to moon disc outline material (for color updates)
    let sceneGroup = null; // Group to hold all 3D objects for scaling
    let cachedTamSvg = null; // Cached TAM SVG content for preloading
    let loadingTamSchemaIndex = null; // Track which schema index is currently being loaded
    let tamPlaneCache = {}; // Cache of TAM planes by schema index to avoid reloading



    // Camera position - keep consistent, use scale instead
    function getCameraPosition() {
      const isPortrait = window.innerHeight > window.innerWidth;
      
      // Use consistent camera distance, adjust Y position slightly for portrait
      if (isPortrait) {
        return { x: 0, y: 1.5, z: 7 };
      } else {
        return { x: 0, y: 2.2, z: 7 };
      }
    }

    // Get camera FOV based on viewport - wider FOV on mobile portrait adds space around sphere
    function getCameraFOV() {
      const isPortrait = window.innerHeight > window.innerWidth;
      const isMobile = window.innerWidth <= 768;
      const isTablet = window.innerWidth >= 768 || /iPad/.test(navigator.userAgent);
      
      // Wider FOV on phone portrait to show more of the scene (adds space around sphere)
      if (isPortrait && isMobile && !isTablet) {
        return 54; // Balanced: shows space around sphere without making it too small
      }
      // Slightly wider on tablet portrait
      if (isPortrait && isTablet) {
        return 52; // Slightly wider for tablet portrait
      }
      return 50; // Default FOV for desktop/landscape
    }

    // Get scale factor based on viewport - use scale instead of camera distance
    function getSceneScale() {
      const isPortrait = window.innerHeight > window.innerWidth;
      const isLandscapeMobile = window.innerHeight < 500 && window.innerWidth > window.innerHeight;
      const isMobile = window.innerWidth <= 768;
      const isTablet = window.innerWidth >= 768 || /iPad/.test(navigator.userAgent);
      
      // Scale down on phone portrait to fit better
      if (isPortrait && isMobile && !isTablet) {
        return 0.75; // Scale down for phone portrait
      }
      // Tablet portrait: slightly smaller than desktop
      if (isPortrait && isTablet) {
        return 0.9; // Slightly smaller for tablet portrait
      }
      // Scale up on mobile landscape to make it bigger
      if (isLandscapeMobile) {
        return 1.15; // Scale to 115% to make it bigger
      }
      return 1.0; // Normal scale for desktop
    }

    // Update scene group scale based on orientation
    function updateSceneScale() {
      if (sceneGroup) {
        const scale = getSceneScale();
        sceneGroup.scale.set(scale, scale, scale);
      }
    }

    // Helper function to validate and get a valid mantra index
    function getValidMantraIndex(savedIndex) {
      // Ensure index is within bounds
      if (savedIndex < 0 || savedIndex >= schemas.length) {
        return 0;
      }

      // Check if the mantra at this index is released
      if (!isMantraReleased(schemas[savedIndex])) {
        // Find first released mantra
        const firstReleased = schemas.findIndex(schema => isMantraReleased(schema));
        return firstReleased >= 0 ? firstReleased : 0;
      }

      return savedIndex;
    }

    // Helper function to save mantra selection
    function saveMantraSelection(index) {
      localStorage.setItem('mantraSelection_index', index.toString());
    }

    async function init() {
      // Load mantras configuration first
      await loadMantrasConfig();

      // Preload TAM SVG to avoid delay on scene switch
      try {
        const tamImagePath = 'images/tam-paths.svg';
        const response = await fetch(tamImagePath);
        cachedTamSvg = await response.text();
        console.log('TAM SVG preloaded successfully');
      } catch (error) {
        console.error('Failed to preload TAM SVG:', error);
      }

      // Validate and set current schema from localStorage
      currentSchema = getValidMantraIndex(currentSchema);

      // Apply initial background gradient and orb color
      applyBackgroundGradient(schemas[currentSchema], schemas[currentSchema]?.patternOpacity);



      // Populate dropdown with loaded mantras
      populateDropdown();

      // Set initial nav button colors
      updateNavButtonColors();

      // Set initial dropdown colors
      updateDropdownColors();

      // Set initial moon disc outline color
      updateMoonDiscOutlineColor();

      // Scene with atmospheric fog
      scene = new THREE.Scene();
      // Fog: color matching the subtle rainbow gradient background
      // Adjusted for closer camera position with moon disk visualization
      scene.fog = new THREE.Fog(0xe5f0f5, 5, 12);

      // Create a group to hold all 3D objects for scaling
      sceneGroup = new THREE.Group();
      scene.add(sceneGroup);

      // Camera
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(getCameraFOV(), aspect, 0.1, 1000);
      const camPos = getCameraPosition();
      camera.position.set(camPos.x, camPos.y, camPos.z);
      camera.lookAt(0, 0, 0);

      // Renderer with enhanced quality settings
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        depth: true,
        logarithmicDepthBuffer: false,
        powerPreference: "high-performance",
        preserveDrawingBuffer: false
      });
      renderer.autoClear = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Increase pixel ratio for better quality (cap at 2 for stability)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = false; // We don't need shadows, saves performance
      document.getElementById('container').appendChild(renderer.domElement);

      // Post-processing (just render pass for now, no bokeh)
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.autoRotate = true;
      controls.autoRotateSpeed = rotationSpeed;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Increased ambient light
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 2, 100); // Increased point light intensity
      pointLight.position.set(0, 0, 0);
      scene.add(pointLight);

      // Create glowing ball
      createGlowBall();

      // Create text ring and TAM character
      createTextRing(currentSchema);
      addTammToSphere(currentSchema);
      setCameraToStartSyllable();

      // Apply initial scale
      updateSceneScale();

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('orientationchange', onOrientationChange);

      // Custom dropdown functionality
      const dropdownTrigger = document.querySelector('.dropdown-trigger');
      const dropdownMenu = document.querySelector('.dropdown-menu');
      const dropdownLabel = document.querySelector('.dropdown-label');
      const dropdownOptions = document.querySelectorAll('.dropdown-option');

      //Set initial dropdown arrow color to match TAM color
      const dropdownArrow = document.querySelector('.dropdown-arrow');
      if (dropdownArrow && schemas[currentSchema] && schemas[currentSchema].tamColor) {
        dropdownArrow.style.borderTopColor = schemas[currentSchema].tamColor;
      }

      dropdownTrigger.addEventListener('click', () => {
        dropdownTrigger.classList.toggle('active');
        dropdownMenu.classList.toggle('show');
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.custom-dropdown')) {
          dropdownTrigger.classList.remove('active');
          dropdownMenu.classList.remove('show');
        }
      });

      // Use event delegation for dynamically created options
      dropdownMenu.addEventListener('click', (e) => {
        const option = e.target.closest('.dropdown-option');
        if (!option) return;

        const value = parseInt(option.dataset.value);
        const text = option.textContent;

        // Update selected state
        dropdownMenu.querySelectorAll('.dropdown-option').forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');

        // Update trigger label
        dropdownLabel.textContent = text;

        // Close dropdown
        dropdownTrigger.classList.remove('active');
        dropdownMenu.classList.remove('show');

        // Update schema
        currentSchema = value;
        saveMantraSelection(currentSchema);

        // Apply background gradient and orb color for new schema
        applyBackgroundGradient(schemas[currentSchema], schemas[currentSchema]?.patternOpacity);



        // Update text ring and TAM for new schema
        createTextRing(currentSchema);
        addTammToSphere(currentSchema);

        // Update dropdown arrow color to match TAM color
        const dropdownArrow = document.querySelector('.dropdown-arrow');
        if (dropdownArrow && schemas[currentSchema] && schemas[currentSchema].tamColor) {
          dropdownArrow.style.borderTopColor = schemas[currentSchema].tamColor;
        }

        // Update navigation button colors
        updateNavButtonColors();

        // Update dropdown colors
        updateDropdownColors();

        // Update moon disc outline color
        updateMoonDiscOutlineColor();

        setCameraToStartSyllable();
        updateAudioInfo();

        // Stop current audio when switching
        if (isPlaying) {
          togglePlayPause();
        }
      });

      // Audio controls
      const playPauseBtn = document.getElementById('play-pause-btn');
      playPauseBtn.addEventListener('click', togglePlayPause);

      audio.addEventListener('ended', () => {
        isPlaying = false;
        playPauseBtn.textContent = '▶';
        document.getElementById('audio-status').textContent = 'Ended';
      });

      audio.addEventListener('error', (e) => {
        // Silently handle audio errors - don't log to console
        const audioStatus = document.getElementById('audio-status');
        if (audioStatus) {
          audioStatus.textContent = 'Audio unavailable';
        }
        // Hide audio controls if audio fails to load
        const audioControls = document.getElementById('audio-controls');
        if (audioControls) {
          audioControls.style.display = 'none';
        }
      });

      audio.addEventListener('canplay', () => {
        if (!isPlaying) {
          document.getElementById('audio-status').textContent = 'Ready to play';
        }
      });

      // Initialize audio
      updateAudioInfo();

      // Fullscreen toggle
      const fullscreenToggle = document.getElementById('fullscreen-toggle');
      const fullscreenEnter = document.querySelector('.fullscreen-enter');
      const fullscreenExit = document.querySelector('.fullscreen-exit');

      // Hide fullscreen button if running as PWA (standalone mode) or if fullscreen API not supported
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
        window.navigator.standalone ||
        document.referrer.includes('android-app://');

      const supportsFullscreen = document.documentElement.requestFullscreen ||
        document.documentElement.webkitRequestFullscreen ||
        document.documentElement.mozRequestFullScreen ||
        document.documentElement.msRequestFullscreen;

      // Hide button if in standalone mode OR if fullscreen not supported (like iOS Safari)
      if (isStandalone || (!supportsFullscreen && /iPad|iPhone|iPod/.test(navigator.userAgent))) {
        fullscreenToggle.style.display = 'none';
      }

      function updateFullscreenIcon() {
        const isFullscreen = document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement;

        if (isFullscreen) {
          fullscreenEnter.style.display = 'none';
          fullscreenExit.style.display = 'block';
        } else {
          fullscreenEnter.style.display = 'block';
          fullscreenExit.style.display = 'none';
        }
      }

      fullscreenToggle.addEventListener('click', () => {
        if (!document.fullscreenElement &&
          !document.webkitFullscreenElement &&
          !document.mozFullScreenElement &&
          !document.msFullscreenElement) {
          // Enter fullscreen
          const elem = document.documentElement;

          // Try standard fullscreen API first
          if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => {
              console.log('Fullscreen request failed:', err);
              alert('Fullscreen mode is not available. On iOS, tap the Share button and select "Add to Home Screen" for a fullscreen experience.');
            });
          } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
          } else if (elem.webkitEnterFullscreen) {
            // iOS fallback
            elem.webkitEnterFullscreen();
          } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
          } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
          } else {
            // Fullscreen not supported
            alert('Fullscreen mode is not available on this device. On iOS, tap the Share button and select "Add to Home Screen" for a fullscreen experience.');
          }
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      });

      // Listen for fullscreen changes (including ESC key)
      document.addEventListener('fullscreenchange', updateFullscreenIcon);
      document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
      document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
      document.addEventListener('MSFullscreenChange', updateFullscreenIcon);

      // Speed controls
      const speedDecreaseBtn = document.getElementById('speed-decrease');
      const speedIncreaseBtn = document.getElementById('speed-increase');
      const speedValueDisplay = document.getElementById('speed-value');

      function updateSpeedDisplay() {
        speedValueDisplay.textContent = speedLevel;
      }

      function updateRotationSpeed() {
        // Quadratic curve: 0.128 * level^2
        // Level 1: ~0.13
        // Level 5: 3.2
        // Level 8: ~8.2
        // Level 10: 12.8 (Matches previous level 8)
        rotationSpeed = 0.128 * speedLevel * speedLevel;
        controls.autoRotateSpeed = rotationSpeed;
        updateSpeedDisplay();

        // Save to local storage
        localStorage.setItem('mantraSpeedLevel', speedLevel);
      }

      // Initialize display
      updateSpeedDisplay();

      speedDecreaseBtn.addEventListener('click', () => {
        if (speedLevel > 0) {
          speedLevel--;
          updateRotationSpeed();
        }
      });

      speedIncreaseBtn.addEventListener('click', () => {
        if (speedLevel < 10) {
          speedLevel++;
          updateRotationSpeed();
        }
      });

      // Mode toggle controls
      const modeBillboardBtn = document.getElementById('mode-billboard');
      const modeRingBtn = document.getElementById('mode-ring');

      modeBillboardBtn.addEventListener('click', () => {
        orientationMode = 'billboard';
        modeBillboardBtn.classList.add('active');
        modeRingBtn.classList.remove('active');
      });

      modeRingBtn.addEventListener('click', () => {
        orientationMode = 'ring';
        modeRingBtn.classList.add('active');
        modeBillboardBtn.classList.remove('active');
      });

      // Navigation controls
      const navPrevBtn = document.getElementById('nav-prev');
      const navNextBtn = document.getElementById('nav-next');

      function navigateToMantra(direction) {
        // Get all released mantras
        const releasedMantras = schemas
          .map((schema, index) => ({ schema, index }))
          .filter(({ schema }) => isMantraReleased(schema));

        if (releasedMantras.length === 0) return;

        // Find current position in released mantras
        const currentPos = releasedMantras.findIndex(({ index }) => index === currentSchema);

        if (currentPos === -1) return;

        // Calculate next position with wrapping
        let nextPos;
        if (direction === 'next') {
          nextPos = (currentPos + 1) % releasedMantras.length;
        } else {
          nextPos = (currentPos - 1 + releasedMantras.length) % releasedMantras.length;
        }

        const nextMantra = releasedMantras[nextPos];

        // Update schema
        currentSchema = nextMantra.index;
        saveMantraSelection(currentSchema);

        // Apply background gradient and orb color for new schema
        applyBackgroundGradient(schemas[currentSchema], schemas[currentSchema]?.patternOpacity);

        // Update text ring and TAM for new schema
        createTextRing(currentSchema);
        addTammToSphere(currentSchema);

        // Update dropdown arrow color to match TAM color
        const dropdownArrow = document.querySelector('.dropdown-arrow');
        if (dropdownArrow && schemas[currentSchema] && schemas[currentSchema].tamColor) {
          dropdownArrow.style.borderTopColor = schemas[currentSchema].tamColor;
        }

        // Update navigation button colors
        updateNavButtonColors();

        // Update dropdown colors
        updateDropdownColors();

        // Update moon disc outline color
        updateMoonDiscOutlineColor();

        // Update dropdown label
        const dropdownLabel = document.querySelector('.dropdown-label');
        if (dropdownLabel) {
          dropdownLabel.textContent = schemas[currentSchema].name;
        }

        // Update selected state in dropdown
        const dropdownOptions = document.querySelectorAll('.dropdown-option');
        dropdownOptions.forEach(opt => {
          if (parseInt(opt.dataset.value) === currentSchema) {
            opt.classList.add('selected');
          } else {
            opt.classList.remove('selected');
          }
        });

        setCameraToStartSyllable();
        updateAudioInfo();

        // Stop current audio when switching
        if (isPlaying) {
          togglePlayPause();
        }
      }

      navPrevBtn.addEventListener('click', () => navigateToMantra('prev'));
      navNextBtn.addEventListener('click', () => navigateToMantra('next'));

      // Setup keyboard shortcuts for navigation and speed control
      document.addEventListener('keydown', (e) => {
        // Only handle arrow keys if not typing in an input/textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }

        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          navigateToMantra('prev');
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          navigateToMantra('next');
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          // Increase speed
          if (speedLevel < 10) {
            speedLevel++;
            updateRotationSpeed();
          }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          // Decrease speed
          if (speedLevel > 0) {
            speedLevel--;
            updateRotationSpeed();
          }
        }
      });

      // Auto-hide controls on desktop (desktop only)
      setupAutoHideControls();

      // Start animation
      animate();
    }

    // Auto-hide controls functionality (desktop only)
    function setupAutoHideControls() {
      // Check if we're on desktop (width >= 769px)
      const isDesktop = () => window.innerWidth >= 769;

      if (!isDesktop()) {
        return; // Don't apply auto-hide on mobile
      }

      const speedControls = document.getElementById('speed-controls');
      const navControls = document.getElementById('nav-controls');
      const fullscreenToggle = document.getElementById('fullscreen-toggle');
      const schemaSelector = document.getElementById('schema-selector');

      if (!speedControls || !navControls) {
        return;
      }

      let hideTimeout = null;
      let mouseMoveTimeout = null;
      const HIDE_DELAY = 3000; // 3 seconds
      const MOUSE_STOP_DELAY = 2000; // 2 seconds of no movement before hiding
      const INITIAL_HIDE_DELAY = 3000; // Initial hide after 3 seconds

      // Helper function to show controls
      function showControls() {
        speedControls.classList.remove('controls-hidden');
        navControls.classList.remove('controls-hidden');
        if (fullscreenToggle) {
          fullscreenToggle.classList.remove('controls-hidden');
        }
        if (schemaSelector) {
          schemaSelector.classList.remove('controls-hidden');
        }
      }

      // Helper function to hide controls
      function hideControls() {
        speedControls.classList.add('controls-hidden');
        navControls.classList.add('controls-hidden');
        if (fullscreenToggle) {
          fullscreenToggle.classList.add('controls-hidden');
        }
        if (schemaSelector) {
          schemaSelector.classList.add('controls-hidden');
        }
      }

      // Clear any existing timeouts
      function clearAllTimeouts() {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        if (mouseMoveTimeout) {
          clearTimeout(mouseMoveTimeout);
          mouseMoveTimeout = null;
        }
      }

      // Schedule hiding controls
      function scheduleHide(delay = MOUSE_STOP_DELAY) {
        clearAllTimeouts();
        hideTimeout = setTimeout(() => {
          if (isDesktop()) {
            hideControls();
          }
        }, delay);
      }

      // Handle mouse movement
      function handleMouseMove() {
        if (!isDesktop()) {
          return;
        }

        // Show controls immediately when mouse moves
        showControls();

        // Clear any pending hide timeout
        clearAllTimeouts();

        // Schedule hide after mouse stops moving
        mouseMoveTimeout = setTimeout(() => {
          scheduleHide(0); // Hide immediately after mouse stops
        }, MOUSE_STOP_DELAY);
      }

      // Handle mouse leaving the viewport
      function handleMouseLeave() {
        if (!isDesktop()) {
          return;
        }
        clearAllTimeouts();
        scheduleHide(0); // Hide immediately when mouse leaves
      }

      // Initial hide after page loads
      scheduleHide(INITIAL_HIDE_DELAY);

      // Add event listeners
      document.addEventListener('mousemove', handleMouseMove, { passive: true });
      document.addEventListener('mouseleave', handleMouseLeave, { passive: true });

      // Also handle mouse leaving the window (for better cross-browser support)
      document.addEventListener('mouseout', (e) => {
        if (!e.relatedTarget && !e.toElement) {
          handleMouseLeave();
        }
      }, { passive: true });

      // Re-check on window resize (in case user switches between desktop/mobile)
      window.addEventListener('resize', () => {
        if (!isDesktop()) {
          // If switched to mobile, show controls and clear timeouts
          clearAllTimeouts();
          showControls();
        } else {
          // If switched to desktop, start the auto-hide behavior
          scheduleHide(INITIAL_HIDE_DELAY);
        }
      }, { passive: true });
    }

    function togglePlayPause() {
      const schema = schemas[currentSchema];
      const playPauseBtn = document.getElementById('play-pause-btn');
      const audioStatus = document.getElementById('audio-status');

      // Check if audio file is available
      if (!schema.audioFile || !audio.src) {
        audioStatus.textContent = 'No audio available';
        return;
      }

      if (isPlaying) {
        audio.pause();
        playPauseBtn.textContent = '▶';
        audioStatus.textContent = 'Paused';
        isPlaying = false;
      } else {
        audio.play().then(() => {
          playPauseBtn.textContent = '⏸';
          audioStatus.textContent = 'Playing';
          isPlaying = true;
        }).catch(err => {
          // Silently handle playback errors - don't log to console
          audioStatus.textContent = 'Audio unavailable';
          // Hide audio controls if playback fails
          const audioControls = document.getElementById('audio-controls');
          if (audioControls) {
            audioControls.style.display = 'none';
          }
        });
      }
    }

    function updateAudioInfo() {
      const schema = schemas[currentSchema];
      const audioControls = document.getElementById('audio-controls');
      const audioTitle = document.getElementById('audio-title');
      const audioStatus = document.getElementById('audio-status');

      // Check if audio file is defined
      if (schema.audioFile) {
        audioTitle.textContent = schema.name;
        audioStatus.textContent = 'Ready to play';
        audio.src = schema.audioFile;
        audio.load();
        // Audio controls are already hidden by default (display: none), so we don't need to show them
      } else {
        // No audio file available - ensure controls stay hidden
        audioControls.style.display = 'none';
        audio.src = '';
        audioStatus.textContent = 'No audio available';
      }
    }

    // ============================================
    // ORB FRESNEL SHADER (VIEW-DEPENDENT GRADIENT)
    // ============================================
    // The orb uses a Fresnel shader so the gradient follows the camera:
    // - Center of visible sphere = white (normal facing camera)
    // - Rainbow ring in middle
    // - Edge/rim = mantra color (normal perpendicular to camera)

    // Reference to orb mesh for shader updates
    let orbMesh = null;

    // Get mantra orb color from schema's orbColor field
    function getMantraOrbColor(schema) {
      if (!schema || !schema.orbColor || !schema.orbColor.hex) {
        return new THREE.Color(0xe8e0f8); // Default soft lavender
      }
      return new THREE.Color(schema.orbColor.hex);
    }

    // Update orb color when mantra changes
    function updateOrbGradient(schema) {
      if (!orbMesh || !orbMesh.material.uniforms) return;
      
      const mantraColor = getMantraOrbColor(schema);
      orbMesh.material.uniforms.mantraColor.value = mantraColor;
      orbMesh.material.needsUpdate = true;
    }

    // Create radial gradient texture for edge glow
    function createEdgeGlowTexture() {
      const size = 512;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      const gradient = ctx.createRadialGradient(
        size / 2, size / 2, size * 0.40,
        size / 2, size / 2, size * 0.50
      );
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
      gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.5)');
      gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    function createGlowBall() {
      // Single orb with Fresnel shader: white center → rainbow → mantra edge
      // Uses view-dependent shading so center is always white from any angle
      const orbGeometry = new THREE.SphereGeometry(2, 64, 64);
      
      // Get initial mantra orb color
      const initialMantraColor = getMantraOrbColor(schemas[currentSchema]);
      
      // Fresnel shader material with angular rainbow rays
      const orbMaterial = new THREE.ShaderMaterial({
        uniforms: {
          mantraColor: { value: initialMantraColor },
          time: { value: 0.0 }, // For sparkle animation
          // 8 rainbow colors matching the page background rays
          rainbow0: { value: new THREE.Color(0xf0e8f8) }, // Soft lavender
          rainbow1: { value: new THREE.Color(0xe8f0f8) }, // Pale blue
          rainbow2: { value: new THREE.Color(0xe8f8f0) }, // Soft mint
          rainbow3: { value: new THREE.Color(0xf8f4e8) }, // Cream
          rainbow4: { value: new THREE.Color(0xf8ece8) }, // Soft pink
          rainbow5: { value: new THREE.Color(0xf4e8f8) }, // Lavender-pink
          rainbow6: { value: new THREE.Color(0xe8e8f8) }, // Periwinkle
          rainbow7: { value: new THREE.Color(0xe8f4f8) }, // Ice blue
          rainbowCycles: { value: 8.0 }, // Number of rainbow repetitions
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vViewDir;
          varying vec2 vScreenPos;
          
          void main() {
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewDir = normalize(-mvPosition.xyz);
            
            // Pass screen position for angular calculation
            vec4 clipPos = projectionMatrix * mvPosition;
            vScreenPos = clipPos.xy / clipPos.w;
            
            gl_Position = clipPos;
          }
        `,
        fragmentShader: `
          uniform vec3 mantraColor;
          uniform float time;
          uniform vec3 rainbow0, rainbow1, rainbow2, rainbow3;
          uniform vec3 rainbow4, rainbow5, rainbow6, rainbow7;
          uniform float rainbowCycles;
          
          varying vec3 vNormal;
          varying vec3 vViewDir;
          varying vec2 vScreenPos;
          
          #define PI 3.14159265359
          
          // Soft sine-based shimmer for natural, flowing sparkle
          float shimmer(vec2 pos, float t, float freq, float speed) {
            return sin(pos.x * freq + t * speed) * sin(pos.y * freq * 1.3 + t * speed * 0.7);
          }
          
          // Get rainbow color based on angle (0-1)
          vec3 getRainbowColor(float t) {
            // t is 0-1 representing position in one rainbow cycle
            float segment = t * 8.0;
            int idx = int(floor(segment));
            float blend = fract(segment);
            
            // Cycle through 8 colors
            if (idx == 0) return mix(rainbow0, rainbow1, blend);
            else if (idx == 1) return mix(rainbow1, rainbow2, blend);
            else if (idx == 2) return mix(rainbow2, rainbow3, blend);
            else if (idx == 3) return mix(rainbow3, rainbow4, blend);
            else if (idx == 4) return mix(rainbow4, rainbow5, blend);
            else if (idx == 5) return mix(rainbow5, rainbow6, blend);
            else if (idx == 6) return mix(rainbow6, rainbow7, blend);
            else return mix(rainbow7, rainbow0, blend);
          }
          
          void main() {
            // Fresnel: 1.0 at center (facing camera), 0.0 at edge (perpendicular)
            float fresnel = dot(vNormal, vViewDir);
            fresnel = clamp(fresnel, 0.0, 1.0);
            
            // Calculate angle from center for rainbow rays (0 to 1, repeating)
            float angle = atan(vScreenPos.y, vScreenPos.x); // -PI to PI
            float normalizedAngle = (angle + PI) / (2.0 * PI); // 0 to 1
            float rayAngle = fract(normalizedAngle * rainbowCycles); // 8 cycles
            
            // Get rainbow color for this ray
            vec3 rainbow = getRainbowColor(rayAngle);
            
            // Radial shimmer - waves radiating outward from center
            float dist = length(vScreenPos); // Distance from center
            
            // Radial waves moving outward (negative time = outward motion)
            float radialWave1 = sin(dist * 12.0 - time * 1.2);
            float radialWave2 = sin(dist * 8.0 - time * 0.8 + 1.5);
            float radialWave3 = sin(dist * 18.0 - time * 1.5);
            
            // Add subtle angular variation so it's not perfectly uniform rings
            float angleVar = sin(normalizedAngle * 16.0 + time * 0.3) * 0.3;
            
            // Combine radial waves with angular variation
            float sparkle = (radialWave1 + radialWave2 * 0.6 + radialWave3 * 0.3 + angleVar) / 2.2;
            sparkle = sparkle * 0.5 + 0.5; // Normalize to 0-1
            sparkle = smoothstep(0.25, 0.75, sparkle); // Soft threshold
            float sparkleIntensity = sparkle * 0.12; // 12% brightness variation
            
            // Apply shimmer to rainbow colors (additive)
            rainbow = rainbow + sparkleIntensity;
            
            // Smooth continuous gradient from center to edge (no hard boundaries)
            // Uses overlapping smoothstep blends for seamless transitions
            
            // White center blend - small bright center (very center only)
            float whiteBlend = smoothstep(0.82, 0.98, fresnel);
            whiteBlend = whiteBlend * whiteBlend * (3.0 - 2.0 * whiteBlend); // Extra smooth cubic
            
            // Rainbow zone - narrow band between mantra and white
            float rainbowStrength = smoothstep(0.55, 0.75, fresnel) * (1.0 - smoothstep(0.80, 0.95, fresnel));
            
            // Mantra color - extends much closer to center
            float mantraBlend = 1.0 - smoothstep(0.15, 0.80, fresnel);
            
            // Build color by layering: start with rainbow, blend mantra at edges, white at center
            vec3 baseColor = rainbow;
            
            // Blend in mantra color - stronger presence extending toward center
            vec3 tintedRainbow = mix(rainbow, mantraColor, 0.35 * mantraBlend);
            baseColor = mix(tintedRainbow, mantraColor, mantraBlend * 0.85);
            
            // Blend rainbow in the transition zone
            baseColor = mix(baseColor, rainbow, rainbowStrength * 0.7);
            
            // Finally blend white at very center
            vec3 color = mix(baseColor, vec3(1.0), whiteBlend);
            
            // Alpha: fully opaque at center, fades at very edge
            float alpha = smoothstep(0.0, 0.25, fresnel);
            alpha = mix(alpha, 1.0, smoothstep(0.2, 0.5, fresnel));
            
            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        depthWrite: false,
        side: THREE.FrontSide
      });
      
      orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
      orbMesh.renderOrder = -1;
      sceneGroup.add(orbMesh);

      // 2. Glow Gradient on the outside (Custom Shader)
      const glowGeometry = new THREE.SphereGeometry(2.8, 64, 64); // Larger for the glow
      const glowMaterial = new THREE.ShaderMaterial({
        uniforms: {
          c: { type: "f", value: 0.2 },
          p: { type: "f", value: 2.5 }, // Falloff power
          glowColor: { type: "c", value: new THREE.Color(0xffffff) },
          viewVector: { type: "v3", value: camera.position }
        },
        vertexShader: `
          uniform vec3 viewVector;
          varying float intensity;
          void main() {
            vec3 vNormal = normalize( normalMatrix * normal );
            vec3 vNormel = normalize( normalMatrix * viewVector );
            intensity = pow( 0.4 - dot(vNormal, vNormel), 4.0 ); // Fresnel-like effect inverted
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          }
        `,
        fragmentShader: `
          uniform vec3 glowColor;
          varying float intensity;
          void main() {
            vec3 glow = glowColor * intensity;
            gl_FragColor = vec4( glow, intensity );
          }
        `,
        side: THREE.BackSide, // Render on inside of outer sphere so it looks like it's surrounding
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });

      // We need to update viewVector in animate loop if camera moves, 
      // but for a simple static glow relative to camera, we can try a simpler approach 
      // or just use a static radial gradient texture on a sprite if the shader is too complex to maintain.

      // Let's try a simpler "Atmosphere" shader approach which is robust
      const atmosphereMaterial = new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) * intensity * 0.5;
          }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        depthWrite: false
      });

      const glow = new THREE.Mesh(glowGeometry, atmosphereMaterial);
      glow.renderOrder = -2;
      sceneGroup.add(glow);

      // 3. Second Gradient for Elegant Flourish (Alternative Style)
      // A slightly larger, more subtle outer glow with a different falloff
      const glowGeometry2 = new THREE.SphereGeometry(3.2, 64, 64);
      const atmosphereMaterial2 = new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            // Softer, wider falloff for the outer flourish
            float intensity = pow(0.5 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
            // Slightly bluish/purplish tint for elegance (matching the background theme)
            gl_FragColor = vec4(0.9, 0.9, 1.0, 1.0) * intensity * 0.3;
          }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        depthWrite: false
      });

      const glow2 = new THREE.Mesh(glowGeometry2, atmosphereMaterial2);
      glow2.renderOrder = -3; // Render before the inner glow
      sceneGroup.add(glow2);

      // Moon disc - WHITE horizontal disc where TAM stands (50% smaller)
      const discGeom = new THREE.CircleGeometry(0.75, 128); // Was 1.5, now 0.75
      const discMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide,
        fog: false,
        depthWrite: true // Write to depth buffer
      });
      moonDisc = new THREE.Mesh(discGeom, discMat);
      moonDisc.rotation.x = -Math.PI / 2;
      moonDisc.position.y = -0.5;
      moonDisc.renderOrder = 0; // Render after orb but before outline
      sceneGroup.add(moonDisc);

      // Outline ring for moon disc (always gray) - 50% smaller
      const outlineGeom = new THREE.RingGeometry(0.735, 0.765, 128); // Was 1.485-1.515, now 0.735-0.765
      moonDiscOutlineMat = new THREE.MeshBasicMaterial({
        color: 0xaaaaaa, // Darker gray for all mantras
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide
      });
      moonDiscOutline = new THREE.Mesh(outlineGeom, moonDiscOutlineMat);
      moonDiscOutline.rotation.x = -Math.PI / 2;
      moonDiscOutline.position.y = -0.49; // Slightly higher than moon disc to avoid z-fighting
      sceneGroup.add(moonDiscOutline);
    }

    function addTammToSphere(schemaIndex) {
      // Use currentSchema if no index provided
      const targetSchemaIndex = schemaIndex !== undefined ? schemaIndex : currentSchema;
      
      // Check if we already have a cached TAM plane for this schema
      if (tamPlaneCache[targetSchemaIndex]) {
        // Hide current TAM plane if it exists
        if (tamPlane && tamPlane !== tamPlaneCache[targetSchemaIndex]) {
          sceneGroup.remove(tamPlane);
        }
        // Use cached TAM plane
        tamPlane = tamPlaneCache[targetSchemaIndex];
        // Make sure it's in the scene
        if (!sceneGroup.children.includes(tamPlane)) {
          sceneGroup.add(tamPlane);
        }
        console.log('Using cached TAM plane for schema:', targetSchemaIndex);
        return;
      }
      
      // Track which schema we're loading
      loadingTamSchemaIndex = targetSchemaIndex;
      
      // Hide existing TAM plane if it exists (don't dispose, it might be cached)
      if (tamPlane) {
        sceneGroup.remove(tamPlane);
        tamPlane = null;
      }

      // Get the TAM image path for the current schema
      const schema = schemas[targetSchemaIndex];
      if (!schema) {
        console.error('Invalid schema index:', targetSchemaIndex);
        loadingTamSchemaIndex = null;
        return;
      }
      const tamImagePath = 'images/tam-paths.svg';
      // Support both new (tamOutlineColor) and old (outlineColor) field names for backward compatibility
      const tamOutlineColor = schema.tamOutlineColor || schema.outlineColor || null;
      const tamColor = schema.tamColor || '#ffffff';
      const syllableStyle = schema.syllableStyle || {};

      // Update moon disc outline color - always use gray
      if (moonDiscOutlineMat) {
        moonDiscOutlineMat.color.set('#aaaaaa');
      }

      // Load SVG file (using cached version if available)
      const loadSvg = cachedTamSvg 
        ? Promise.resolve(cachedTamSvg)
        : fetch(tamImagePath).then(response => response.text());

      loadSvg.then(svgText => {
        // Parse SVG
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
        const svgElement = svgDoc.documentElement;

        // Find the path element (should be the first/only path in our SVG)
        const pathElement = svgElement.querySelector('path');

        if (pathElement) {
          // Apply fill color from JSON
          pathElement.setAttribute('fill', tamColor);

          // Apply stroke/outline if specified
          if (tamOutlineColor && tamOutlineColor !== '#000000') {
            pathElement.setAttribute('stroke', tamOutlineColor);
            pathElement.setAttribute('stroke-width', '4'); // Thinner outline
          }
        }

        // Serialize the modified SVG back to string
        const serializer = new XMLSerializer();
        const modifiedSvgString = serializer.serializeToString(svgElement);

        // Create an image from the SVG
        const img = new Image();
        const svgBlob = new Blob([modifiedSvgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);

        img.onload = function () {
          // Check if we're still loading the correct schema (prevent race condition)
          if (loadingTamSchemaIndex !== targetSchemaIndex) {
            console.log('TAM loading cancelled: schema changed during load');
            URL.revokeObjectURL(url);
            return;
          }
          
          // Create a canvas to render the SVG at high resolution
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Use higher resolution for crisp rendering when foreshortened (4x the SVG dimensions)
          const scale = 4;
          canvas.width = img.width * scale;
          canvas.height = img.height * scale;

          // Enable high-quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';

          // Draw the SVG image to canvas
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

          // Create Three.js texture from canvas
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearMipmapLinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = true;
          // Apply anisotropic filtering for sharp rendering at angles
          if (renderer && renderer.capabilities) {
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
          } else {
            texture.anisotropy = 16; // Default high anisotropy
          }
          texture.needsUpdate = true;

          // Get aspect ratio from SVG to avoid distortion
          const aspectRatio = img.width / img.height;
          const height = 2.0; // Smaller, relative to moon disk
          const width = height * aspectRatio;

          console.log('TAM SVG loaded and rendered to texture');
          console.log('SVG dimensions:', img.width, 'x', img.height);
          console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
          console.log('TAM plane size:', width, 'x', height);
          console.log('TAM aspect ratio:', aspectRatio);
          console.log('TAM color:', tamColor);
          console.log('TAM outline color:', tamOutlineColor);

          // Create a plane geometry for the character with correct aspect ratio
          const planeGeometry = new THREE.PlaneGeometry(width, height);

          // Use basic material for SVG (colors are already applied in the SVG)
          const planeMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            depthTest: true,
            depthWrite: true,
            fog: false
          });

          // Double-check we're still loading the correct schema before adding
          if (loadingTamSchemaIndex !== targetSchemaIndex) {
            console.log('TAM loading cancelled: schema changed before adding to scene');
            // Dispose of resources
            planeGeometry.dispose();
            planeMaterial.dispose();
            texture.dispose();
            URL.revokeObjectURL(url);
            return;
          }
          
          tamPlane = new THREE.Mesh(planeGeometry, planeMaterial);

          // Position TAM standing on the moon disc (bottom at y = -0.5)
          tamPlane.position.set(0, height / 2 - 0.5, 0);
          tamPlane.renderOrder = 0;

          console.log('TAM plane created and added to scene', tamPlane);
          sceneGroup.add(tamPlane);
          console.log('TAM plane added to scene. Total objects in scene:', scene.children.length);

          // Cache the TAM plane for this schema to avoid reloading
          tamPlaneCache[targetSchemaIndex] = tamPlane;

          // Clear loading flag
          loadingTamSchemaIndex = null;

          // Clean up the blob URL
          URL.revokeObjectURL(url);
        };

        img.onerror = function (error) {
          console.error('Failed to load SVG image:', error);
          loadingTamSchemaIndex = null;
        };

        img.src = url;
      })
          .catch(error => {
            console.error('Failed to load SVG file:', error);
            loadingTamSchemaIndex = null;
          });
    }

    function createParticles() {
      // Particles hidden
      // const particlesGeometry = new THREE.BufferGeometry();
      // const particlesCount = 200;
      // const positions = new Float32Array(particlesCount * 3);

      // for (let i = 0; i < particlesCount * 3; i++) {
      //   positions[i] = (Math.random() - 0.5) * 15;
      // }

      // particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      // const particlesMaterial = new THREE.PointsMaterial({
      //   color: 0x4488ff,
      //   size: 0.05,
      //   transparent: true,
      //   opacity: 0.6,
      //   blending: THREE.AdditiveBlending
      // });

      // const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      // scene.add(particles);
    }

    // Orientation mode: 'billboard' or 'ring'
    let orientationMode = 'ring';

    // Helper function to determine if a hex color is "light" based on luminance
    function isLightColor(hexColor) {
      // Remove # if present
      const hex = hexColor.replace('#', '');
      // Parse RGB values
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      // Calculate relative luminance (perceived brightness)
      // Using the formula: 0.299*R + 0.587*G + 0.114*B
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      // Consider colors with luminance > 0.65 as "light"
      return luminance > 0.65;
    }

    // Helper function to create texture from canvas with outlined text and proper aspect ratio
    // Returns { texture, aspectRatio } where aspectRatio = width/height
    function createTextTextureWithOutline(text, fontSize = 64, fillColor = '#ffffff', outlineColor = '#000000', outlineWidth = 3) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Set font and measure text
      const font = `bold ${fontSize}px "Crimson Pro", serif`;
      ctx.font = font;
      const metrics = ctx.measureText(text);

      // Get text dimensions with robust fallbacks
      const textWidth = Math.max(metrics.width, fontSize * 0.5);
      const textHeight = Math.max(
        (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0),
        fontSize * 0.85 // Fallback based on typical font metrics
      );

      // Add padding around text (account for outline)
      const padding = fontSize * 0.4 + outlineWidth * 2;
      const canvasWidth = Math.max(64, Math.ceil(textWidth + padding * 2));
      const canvasHeight = Math.max(64, Math.ceil(textHeight + padding * 2));

      // Set canvas size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Redraw with correct canvas size (need to re-set font after resize)
      ctx.font = font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw outline first
      if (outlineWidth > 0) {
        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = outlineWidth * 2;
        ctx.lineJoin = 'round';
        ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
      }

      // Draw fill
      ctx.fillStyle = fillColor;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = true;
      // Apply anisotropic filtering for sharp rendering at angles
      if (renderer && renderer.capabilities) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      } else {
        texture.anisotropy = 16; // Default high anisotropy
      }
      texture.needsUpdate = true;

      const aspectRatio = canvas.width / canvas.height;

      return {
        texture,
        aspectRatio: isNaN(aspectRatio) || aspectRatio <= 0 ? 1 : aspectRatio
      };
    }

    // Helper function to create texture from canvas with outlined text
    function createTextTexture(text, fillColor, outlineColor, outlineWidth, fontSize = 80) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Set canvas size (higher resolution for better quality at angles)
      canvas.width = 1024;
      canvas.height = 512;

      // Clear canvas with transparent background
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Enable better text rendering
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      // Setup font
      ctx.font = `bold ${fontSize}px "Crimson Pro", serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Draw outline first (if width > 0)
      if (outlineWidth > 0) {
        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = outlineWidth * 2; // Canvas uses total width
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.miterLimit = 2;
        ctx.strokeText(text, centerX, centerY);
      }

      // Draw fill on top
      ctx.fillStyle = fillColor;
      ctx.fillText(text, centerX, centerY);

      // Create texture with better settings
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      // Apply anisotropic filtering to reduce shimmer at angles
      if (renderer && renderer.capabilities) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      }
      texture.needsUpdate = true;

      return texture;
    }

    function setCameraToStartSyllable() {
      if (textMeshes.length === 0) return;

      const schema = schemas[currentSchema];
      const startIndex = schema.startIndex || 0;
      const syllables = schema.syllables;
      const radius = 1.7; // Match createTextRing moon disk orbit radius
      const angleStep = (Math.PI * 2) / syllables.length; // Match createTextRing
      const baseAngle = Math.PI / 2; // Match createTextRing
      const angleOffset = -angleStep * startIndex;
      const startAngle = angleStep * startIndex + angleOffset + baseAngle;

      // Calculate start syllable position on the ring
      const startX = Math.cos(startAngle) * radius;
      const startZ = Math.sin(startAngle) * radius;

      // Keep target at center (0,0,0) to keep scene centered on blue sphere
      controls.target.set(0, 0, 0);
      const camPos = getCameraPosition();
      camera.position.set(camPos.x, camPos.y, camPos.z);
      controls.update();
    }

    function createTextRing(schemaIndex) {
      // Remove old text meshes
      textMeshes.forEach(mesh => {
        // Dispose of textures and materials to free memory
        if (mesh.material.map) mesh.material.map.dispose();
        mesh.material.dispose();
        mesh.geometry.dispose();
        sceneGroup.remove(mesh);
      });
      textMeshes = [];

      const syllables = schemas[schemaIndex].syllables;
      const startIndex = schemas[schemaIndex].startIndex || 0;
      const radius = 1.7; // Orbit around moon disk edge (moon disk radius is 1.5)
      const syllableY = -0.35; // Closer to moon disk level
      const angleStep = (Math.PI * 2) / syllables.length; // Positive for counter-clockwise (right-to-left)

      // Base angle to align ring so index 0 is at positive Z (facing camera)
      const baseAngle = Math.PI / 2;

      // Offset angle so start syllable faces camera
      const angleOffset = -angleStep * startIndex;

      // Get syllable style configuration
      // Syllables are filled with TAM color and have light/white outline
      // Exception: light mantras (indicated by tamOutlineColor or light TAM) get a dark-ish outline
      const schema = schemas[schemaIndex];
      const tamColor = schema.tamColor || '#ffffff';
      const tamOutlineColor = schema.tamOutlineColor || null;
      
      // Determine if this is a "light" mantra by checking tamOutlineColor or TAM luminance
      const isLightMantra = tamOutlineColor !== null || isLightColor(tamColor);
      
      const fillColor = tamColor;
      const outlineColor = isLightMantra ? 'rgba(60, 60, 60, 0.7)' : 'rgba(255, 255, 255, 0.85)';
      const outlineWidth = 4; // Fixed outline width for consistent look

      // Pre-create all textures to get their aspect ratios
      const syllableData = syllables.map(syl => {
        const { texture, aspectRatio } = createTextTextureWithOutline(
          syl,
          72,
          fillColor,
          outlineColor,
          outlineWidth
        );
        return { text: syl, texture, aspectRatio };
      });

      // Calculate uniform height and resulting widths
      const baseHeight = 0.5; // Uniform height for all syllables
      const syllableWidths = syllableData.map(d => baseHeight * d.aspectRatio);
      const totalArcWidth = syllableWidths.reduce((a, b) => a + b, 0);
      const circumference = 2 * Math.PI * radius;
      const numSyllables = syllables.length;

      // Calculate scale to fit all syllables with gaps (syllables take ~75% of circumference for larger text)
      const targetTextRatio = 0.75;
      const availableArc = circumference * targetTextRatio;
      const uniformScale = availableArc / totalArcWidth;
      const scaledHeight = baseHeight * uniformScale;
      const scaledWidths = syllableWidths.map(w => w * uniformScale);
      const totalScaledArc = scaledWidths.reduce((a, b) => a + b, 0);
      const gapSize = (circumference - totalScaledArc) / numSyllables;

      // Position syllables with even gaps
      // Start at baseAngle + offset, but subtract the gap/width we'll add before positioning
      // so that the start syllable (index 0) ends up exactly at baseAngle + angleOffset
      const firstSyllableWidth = scaledWidths[0];
      let currentAngle = baseAngle + angleOffset - (gapSize / 2 + firstSyllableWidth / 2) / radius;

      syllableData.forEach((data, i) => {
        const syllableWidth = scaledWidths[i];

        // Add half gap + half syllable width to get center position
        currentAngle += (gapSize / 2 + syllableWidth / 2) / radius;

        const x = Math.cos(currentAngle) * radius;
        const z = Math.sin(currentAngle) * radius;

        // Use natural aspect ratio for geometry
        const geom = new THREE.PlaneGeometry(syllableWidth, scaledHeight);
        const mat = new THREE.MeshBasicMaterial({
          map: data.texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: true,
          depthWrite: false,
          opacity: 1.0,
          alphaTest: 0.01
        });
        const textMesh = new THREE.Mesh(geom, mat);
        textMesh.position.set(x, syllableY, z);

        // Face outward from center (ring mode)
        textMesh.lookAt(x * 2, syllableY, z * 2);

        // Store angle for later orientation updates
        textMesh.userData.angle = currentAngle;
        textMesh.userData.originalIndex = i;
        textMesh.userData.revealOrder = (i - startIndex + syllables.length) % syllables.length;

        // Start with all syllables visible (no initial hiding)
        textMesh.material.opacity = 1.0;

        // Add to scene
        sceneGroup.add(textMesh);
        textMeshes.push(textMesh);

        // Move to end of this syllable + half gap for next
        currentAngle += (syllableWidth / 2 + gapSize / 2) / radius;
      });

      // Reveal animation disabled - syllables are immediately visible
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update time uniform for sparkle animation
      if (orbMesh && orbMesh.material.uniforms && orbMesh.material.uniforms.time) {
        orbMesh.material.uniforms.time.value = performance.now() * 0.001; // Time in seconds
      }

      // Make TAM always face the camera (Y-axis only)
      if (tamPlane) {
        tamPlane.lookAt(camera.position.x, tamPlane.position.y, camera.position.z);
      }

      // Handle syllable orientation based on mode
      textMeshes.forEach((mesh) => {
        if (orientationMode === 'billboard') {
          // Billboard mode: always face camera
          mesh.lookAt(camera.position);
        } else {
          // Ring mode: face outward from center (already set in createTextRing, but update for rotation)
          const outwardPosition = new THREE.Vector3(
            mesh.position.x * 2,
            mesh.position.y,
            mesh.position.z * 2
          );
          mesh.lookAt(outwardPosition);
        }
      });

      // Reveal animation removed - syllables are always visible

      // Update text: floating animation
      const baseSyllableY = -0.35; // Match createTextRing syllableY
      textMeshes.forEach((mesh, i) => {
        // Remove wavy animation
        mesh.position.y = baseSyllableY;
      });

      controls.update();
      composer.render();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.fov = getCameraFOV(); // Update FOV based on viewport
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);

      // Adjust camera position based on new dimensions
      const camPos = getCameraPosition();
      camera.position.set(camPos.x, camPos.y, camPos.z);

      // Update scene scale for mobile portrait
      updateSceneScale();
    }

    function onOrientationChange() {
      // Wait for resize to complete
      setTimeout(() => {
        onWindowResize();
        updateSceneScale();
      }, 100);
    }

    // Initialize when page loads
    init();
  </script>
</body>

</html>